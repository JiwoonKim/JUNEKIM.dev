---
date: '2019-09-25'
title: "[OOP] 04. 상속"
description: OOP 정리
tags: ['Java', '객체지향프로그래밍']
---

### 상속 (Inheritance)
__기존의 클래스로부터 새로운 클래스를 유도하는 것__
- __부모 클래스__ (__parent class__): 기존에 있는 클래스 (또는 super class라고도 함)
- __자식 클래스__ (__child class__): 상속된 클래스 (또는 subclass라고도 함)
    - 자식 클래스는 부모 클래스의 데이터와 메소드를 __기본적으로 모두 이어 받는다__
    - 상속 받은 클래스에는 __변수와 메소드를 추가할 수 있다__
- 상속을 통해 __코드를 재사용__ 하기 때문에 __소프트웨어의 생산성을 높일 수 있다__
```java
    // 부모 클래스: 드래곤 정의
    public class Dragon {
        protected Boolean hasWings;
        public void fly() { System.out.println("flying..."); }
    }
    // 자식 클래스: 나이트퓨리 드래곤 정의
    public class Nightfury extends Dragon {
        // hasWings, fly()을 상속받음
        // 자기만의 변수와 함수 추가 가능
        private Boolean hasPlasmaBeam;
        public void attack { System.out.println("plasma beam!"); }
    }
```
- cf) 자바 언어에서는 다중 상속을 지원하지 않는다!

#### # 상속 관계 vs 포함 관계
- __상속관계__ (inheritance): 자식 클래스 `is-a` 부모 클래스의 일종
- __포함관계__ (aggregations): 클래스 `has-a` 다른 클래스
```java
    public class Person {
        private String name;
    }
    // 상속관계 (is-a): 부모 클래스의 연장선
    public class Artist extends Person {
        private boolean artistic;
    }
    // 포함관계 (has-is): 멤버로 다른 클래스를 소유
    public class room {
        private Person resident;
        private int roomNumber;
    }
```

#### # 상속의 접근 범위
상속을 받더라도 접근 지정자의 종류와 상속 관계인 두 클래스의 상대적인 위치에 따라, 자식 클래스가 부모 클래스의 데이터와 함수에 접근이 가능한지의 여부가 달라진다
- `public` & `protected`: __언제든 상속받아 접근 가능__
- `default`: 두 클래스가 __동일한 패키지에 존재할 경우에만__, 상속받아 접근 가능
- `private`: 절대 __접근 불가__ (상속의 의미가 크게 없음)
```java
    public class Parent {
        public int publicVal;
        protected int protectedVal;
        default int defaultVal;
        private int privateVal;
    }
    public class Child extends Parent {
        void set() {
            publicVal = 1;
            protectedVal = 1;
            defaultVal = 2; // 다른 패키지면, 컴파일 오류
            privateVal = -1; // 무조건 컴파일 오류; getPrivateVal()을 통한 접근이 권장됨
        }
    }
```

#### # Super 레퍼런스 (`super`)
해당 객체의 __부모 클래스를 가르키는 레퍼런스__ 
- 자식 클래스에서 __부모 클래스의 데이터 또는 메소드에 접근__ 할 때 사용된다
```java
    public class Dragon {
        public void fly() { System.out.print("flying..."); }
    }
    public class Nightfury extends Dragon {
        public void fly() { 
            // 부모 클래스의 데이터 및 메소드 호출
            super.fly();
            System.out.println("in lightning speed!"); 
        }
    }
```
- 메소드의 경우, 주로 부모로부터 상속받은 메소드를 자식이 수정(__메소드 오버라이딩__)할 때, 부모 메소드를 호출하는 경우에 사용된다. 나머지 메소드는 어차피 상속받았기 때문에 굳이 super로 접근할 필요가 없고, 오로지 메소드 오버라이딩 시 부모 메소드가 필요될 때에만 사용하면 된다
- 단, 생성자 메소드는 상속되지 않기 때문에, __파라미터가 있는 부모 생성자를 기반으로 자식 생성자를 정의__ 하고자 할 때에도 사용되기도 한다
```java
    public class Dragon {
        public Dragon(boolean hasWings) {
            this.hasWings = hasWings;
        }
    }
    public class Nightfury extends Dragon {
        public Nightfury(boolean hasWings, boolean hasPlasmaBeam) {
            // 부모의 기본 생성자 이외의 생성자 코드를 재사용
            // (super가 없다면, 자동으로 Master()이 호출 됨)
            super(hasWings);
            // 그 외 부분 정의
            this.hasPlasmaBeam = hasPlasmaBeam;
        }
    }
```
    - 기본적으로 모든 자식 생성자는 부모의 기본 생성자를 먼저 호출한 후,  자식 생성자를 호출하는 순서를 가진다 (만약 상위 생성자에 기본 생성자가 없다면, 컴파일 오류가 생김)

### 업캐스팅과 다운캐스팅
업캐스팅된 레퍼런스를 사용하면 메소드가 더 전형적인 형태의 객체를 메소드 인자로 받게끔 정의할 수 있고 컴파일 오류도 덜 남
- __업캐스팅__ (__upcasting__): 슈퍼 클래스 레퍼런스가 서브 클래스 레퍼런스 가르키기
    - 단, 슈퍼 클래스 레퍼런스는 오로지 슈퍼 클래스에서 정의된 데이터와 함수들만 접근 가능 (서브 클래스에서 추가된 멤버들을 접근 불가능)
- __다운캐스팅__ (__downcasting__): 서브 클래스 레퍼런스가 슈퍼 클래스 레퍼런스 가르키기
```java
// 업캐스팅을 통해 자동으로 타입 변환이 이루어짐
Child c = new Parent();
// 업캐스팅 되었던 것을 다시 강제로 되돌리기
Parent p = (Parent) c;
```
- cf) `instanceof` 연산자: 레퍼런스가 가리키는 객체의 원래 타입을 식별하는데 사용 (true / false 반환)
```java
Person d1 = new Nightfury();
if (d1 instanceof Dragon) System.out.println("d1 is a dragon");   // 출력
if (d1 instanceof Nightfury) System.out.println("d1 is a nightfury");   // 출력
if (d1 instanceof Pokemon) System.out.println("p1 is Pokemon"); // X
```
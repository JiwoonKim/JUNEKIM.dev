---
date: '2019-10-01'
title: "[OOP] 05. 다형성"
description: OOP 정리
tags: ['Java', '객체지향프로그래밍']
---

### 다형성 (Polymorphism)
`poly`(many) + `morphs`(forms)가 합쳐진 뜻으로 __한 객체가 여러 가지 형태를 취할 수 있는 능력__ 을 의미
- __한 클래스가 다른 클래스로부터 상속되었다면__, 그 클래스의 __객체는 다형성을 가진다__ 고 할 수 있다
```java
public class Animal { ... };
public class Deer extends Animal { ... };
Deer deerForm = new Deer();   // 사슴 형태일 수도 있고
Animal animalForm = deerForm; // 동물 형태일 수도 있다
```
- 다만, 단순히 다양한 형태를 가질 수 있다는 의미보다는, 주로 객체가 가진 __한 행동이 다양한 형태로 표현될 수 있다__ 는 의미로 쓰인다 (즉, __메소드와 관련__ 하여 주로 다형성이 얘기된다)
- __자바의 모든 클래스는 다형성을 가진다__ (모든 클래스는 Object 클래스로부터 상속되기 때문) 

#### 다형성의 종류
1. 부모 클래스 레퍼런스가 자식 클래스의 객체를 가르키는 경우(업캐스팅)가 가장 대표적이다??
2. 메소드 오버로딩
3. 메소드 오버라이딩

### 메소드 오버로딩 (Method Overloading)
한 클래스 내에서 이름이 같은 메소드가 여러 개 존재
- 반드시 __메소드의 인자 개수__ 또는 __타입__ 이 __달라야 한다__ (+ 리턴 타입이 추가로 달라져도 괜찮다)
- 컴파일 시에 중복된 메소드 중 호출되는 메소드가 결정된다 (정적 바인딩)
```java
    // 생성자 메소드 오버로딩
    public Animal(String s) {
        name = s;
    }
    public Animal(String s, String a) {
        this();
        action = a;
    }
```
```java
    // 메소드 오버로딩
    public void draw() {
        System.out.println(this.name);
    }
    public void draw(String action) { // 매개변수 변화
        System.out.println(action + " ");
        this.draw();
    }
    public String draw(String action, boolean changeName) { // 매개변수 & 리턴타입 변화
        this.name = action + " " + this.name;
        this.draw();
        return this.name;
    }
```

### 메소드 오버라이딩 (Method Overriding)
__부모 클래스의 메소드를__ 자식 클래스에서 __재정의하는 것__
- __메소드 이름, 인자 타입 및 개수, 리턴 타입 등이 일치해야__ 된다 (하나라도 다르면 메소드 오버라이딩이 실패하고, 자식 클래스에 오버로딩된 메소드가 추가되기만 함)
- static, private 또는 final 메소드는 오버라이딩 될 수 없으며, 오버라이딩된 메소드의 접근 지정자는 상위 클래스 메소드의 접근 지정자보다 범위가 넓어야만 한다 
- 실행 시간에 오버라이딩된 메소드 찾아 호출한다 (동적 바인딩)
```java
    public class Master {
        public void work() { System.out.println("스승은 뛰어났다!"); }
    }
    public class Apprentice extends Master {
        // 메소드 오버라이딩
        public void work() {
            super.work() { System.out.println("제자는 더 뛰어났다!"); }
        }
    }
```

#### 동적 바인딩 (Dynamic Binding)
- 오버라이딩 된 메소드는 무조건 실행되도록 __동적 바인딩__ 된다 (부모 클래스의 메소드를 무시하고, 자식 클래스에서 새로 작성된 메소드가 실행됨)
```java
    public class Master {
        public String getState() { return "스승은 뛰어났다!"; }
        public void show() { 
            System.out.println(getState()); 
        }
    }
    public class Apprentice extends Master {
        // 오버라이딩된 메소드
        public String getState() { return "제자는 더 뛰어났다!"; }
    }
    // 드라이버 코드
    public class Test {
        public static void main(String[] args) {
            Master blue = new Master();
            blue.show(); // "스승은 뛰어났다!" 출력 
            Apprentice bluer = new Apprentice();
            // 동적 바인딩에 의해 오버라이딩된 work()가 호출됨
            bluer.show(); // "제자가 더 뛰어났다!" 
        }
    }
    // 설명: bluer.show() -> 상속받은 show() -> work()
    // BUT, 동적 바인딩 때문에 Master.work() 대신, 오버라이딩된 Apprentice.work()를 무조건 호출됨
```
- 업캐스팅된 레퍼런스이더라도, 가르키는 객체의 오버라이딩된 메소드를 무조건 실행한다
```java
    public class Master {
        public void show() {
            System.out.println("스승은 뛰어났다!");
        }
    }
    public class Master {
        public void show() {
            System.out.println("제자는 더 뛰어났다!");
        }
    }
    public class Test {
        Master disguised = new Apprentice(); // 업캐스팅
        disguised.show() // "제자가 더 뛰어났다!"
    }
    // 업캐스팅된 레퍼런스는 하위 클래스의 변수 및 메소드에 접근할 수 없는 것이 원칙이지만,
    // 동적 바인딩에 의해 객체의 오버라이딩된 메소드가 호출됨
```
cf) super로 접근한 메소드는 동적바인딩이 되지 않는다
---
date: '2019-10-01'
title: "[OOP] 06. 추상 클래스와 인터페이스"
description: OOP 정리
tags: ['Java', '객체지향프로그래밍']
---

### 계층구조
그림??

#### cf) 자바 클래스 계층구조
- 모든 클래스는 `java.lang.Object`로부터 상속된다 (__Object 클래스는 최상위 클래스__)
```java
public class Animal { // extends Object가 생략되었지만 자동 상속됨
    ...
}
```
- 기본 메소드: `toString()`, `equals()`, `getClass()`, `finalize()`, `clone()` 등이 모든 클래스에 상속되며, 가능하면 클래스 사용에 맞게 오버라이딩하면 좋다

### 추상 클래스 (Abstract Class)
계층적 상속 관계를 갖는 클래스 구조를 만들 때 사용하는 상위 클래스
- 상속과 다형성을 통해 __하위 클래스를 여러가지 만들 용도로 정의하는 상위 클래스__ 이다
- 실제로 객체를 만드는 용도가 아니기 때문에, 추상 클래스는 객체를 만들 수 없다 (컴파일 오류)
- 추상 클래스에서는 __추상 메소드를 사용하여 선언만__ 하고, 상속을 통해 서브 클래스에서 이를 __오버라이딩함으로써 구체적인 구현 방법을 정의__ 한다.
- __추상 메소드__ (__abstract method__): 선언되어 있으나 구현되어 있지 않은 메소드
```java
    // 추상 메소드가 있으므로 추상 클래스 |  // 추상 메소드가 없어도 추상 클래스 가능
    abstract class Animal {             |  abstract class Animal {
        String name;                    |      String name;
        public abstract void draw();    |      public void draw() { 
    }                                   |          System.out.println(name); 
                                        |      }
                                        |  }
```
    - 선언: `abstract` 접근 지정자 + 리턴 타입 + 이름
    - __추상 메소드를 하나라도 가지고 있는 경우__ 추상 클래스이다
    - 추상 메소드를 가지고 있지 않더라도, __추상 클래스로 선언된 경우__ 도 추상 클래스로 인정된다

### 인터페이스 (Interface)
__상수와 추상 메소드로만 이루어진 클래스__
- 일종의 블루 프린트처럼 오로지 최종적인 정의만 제공할 뿐, 구현은 상속을 통해서만 가능하게 만든 구조이다 
- 인터페이스를 이용하여 __다중 상속을 구현__ 할 수 있다 (자바의 클래스는 다중 상속이 불가능하지만 인터페이스를 이용해서 구현이 가능)
- 추상 클래스와 마찬가지로 상속을 통한 계층 구조를 만드는 목적으로 만들어졌기 때문에 객체를 생성할 수 없다
- 레퍼런스 변수 타입으로는 사용이 가능하다 
```java
public interface Animal {
    public void draw();
}
```
    - 선언: 접근 지정자 + `interface` + 이름
    - 모든 메소드가 추상 메소드이므로 `public abstract` 생략 가능
    - 모든 변수가 상수이므로 `public static final` 생략 가능

#### 인터페이스 상속 및 구현
- 인터페이스를 상속한 클래스를 정의함으로써 해당 클래스의 객체를 생성하여 사용할 수 있다.
- 상속된 클래스에서는 인터페이스의 추상 메소드 구현을 정의 (오버라이딩) 해야 사용이 가능하다 
```java
public interface Animal {
    public void draw();
}
public interface Vegetarian {
    public void eats();
}
// 인터페이스를 상속한 클래스 정의 (다중 상속 가능)
public class Deer implements Animal, Vegetarian {
    // 인터페이스의 추상 메소드를 오버라이딩해야 함
    public void draw() {
        System.out.print("deer");
    }
    public void eats() {
        System.out.println("eats grass");
    }
}
```
```java
// 드라이버 코드
public class Sketch {
    public static void main(String[] args) {
        Deer d1 = new Deer();
        d1.draw();
        d1.eats();
    }
}
```

#### 추상 클래스와 인터페이스 비교
- 추상 클래스: 일반 메소드 포함 가능, 상수, 변수 필드 포함 가능, 모든 서브 클래스에 공통된 메소드가 있는 경우, 추상 클래스가 적합
- 인터페이스: 모든 메소드가 추상 메소드, 상수 필드만 포함 가능, 다중 상속 지원

When we talk about abstract classes we are defining characteristics of an object type; specifying what an object is. 
When we talk about an interface and define capabilities that we promise to provide, we are talking about establishing a contract about what the object can do.

Consider using abstract classes if :
You want to share code among several closely related classes.
You expect that classes that extend your abstract class have many common methods or fields, or require access modifiers other than public (such as protected and private).
You want to declare non-static or non-final fields. 
Consider using interfaces if :
You expect that unrelated classes would implement your interface. For example,many unrelated objects can implement Serializable interface.
You want to specify the behaviour of a particular data type, but not concerned about who implements its behaviour.
You want to take advantage of multiple inheritance of type.

### 인터페이스 레퍼런스
- 추상 클래스와 마찬가지로 상속을 통한 계층 구조를 만드는 목적으로 만들어졌기 때문에 객체를 생성할 수 없다
- 레퍼런스 변수 타입으로는 사용이 가능하다 
```java
```
---
date: '2019-03-24'
title: "Google Kick Start 2019 - Round A"
description: Google Kick Start 2019 round A 후기
tags: ['코딩 대회', '알고리즘']
---
> Kick Start 2019 대회 후기

### Round A

### 1. Training
s[N] 개의 값 중 P개를 골라 그 중 최대값과 각각 다른 값의 __차이의 합의 최소값 구하기__

#### 다이나믹 프로그래밍으로 문제풀기
1. _선택한 P개 중_ ( s[최대] - s[다른 거 1] ) + ( s[최대] - s[다른 거 2] ) + ... + ( s[최대] - s[다른 거 p-1번째] ) => __총 P-1 개의 차이값들의 합__
2. 그 __차이의 합이 최소인 값__ 구하기

#### 내가 푼 방법
1. 일단 차이의 합이 최소가 되야하므로, 선택한 P개의 값들은 __정렬했을 때 연속된 값들__ 이어야 한다. so 일단 오름차순으로 __s[N] 정렬__
2. __다이나믹 프로그래밍으로__ 풀기: s[N]개 중 처음부터 P개씩 묶는다는 생각으로, P 개 중 최대값인 s[P]를 기준으로 그전 P-1 개의 값들과의 __차이의 합을 계산__
    - 비효율적인 방법: ( s[P] - s[P-1] ) + ( s[P] - s[P-2] ) + ... + ( s[P] - s[1] ) => 총 P-1개의 차이의 합
    - 효율적인 방법: d[n] = d[n-1] + ( s[n] - s[n-1]) * (P-1) - ( s[n-1] - s[n-p] )
3. d[n] 값 중 __최소값 구하기__

#### 1등이 푼 방법 (비교)
과정은 같으나 다이나믹 프로그래밍으로 계산했을 때, __계산하는 방법이 다르다__
- __d[n] = ( s[n] * P ) - ( s[n] s[n-1] + ... + s[1] )__
    - 즉, (최대값 x P)에서 최대값을 포함한 연속된 P개의 값의 합을 빼는 방법
    - d[n]을 따로 저장할 필요 없고 사실 후자를 sum_p_개[n] = ( s[n] + s[n-1] + ... + s[1] ) 식을 사용하여 저장함
    - sum[n] = s[1] ~ s[n]의 합으로 해 놓고서 실제로 __sum_p_개[n] = sum[n] - sum[n-p+1]을 사용함__

#### 결론
- 다이나믹 프로그래밍을 사용하는 큰 그림은 일단 맞추었다! 
    - 각 test case 마다 O(N)의 시간복잡도를 가능한 줄였다!
- but, 1등이 계산한 방법이 더 효율적인 듯! (한 번 이해를 하니, 더 간단하게 )
- 단순히 지시나 조건에 따라서 연산을 할 것이 아니라, __한 단계 더 거쳐서 식을 더 번거롭지 않게 만들 수 있는 방법이 있는지 살펴보기__

### 2. Parcels

### 3. Contention


### What I learned

#### 채점 결과 WA (Wrong Answer) 의미
1. __Sample Failed__: Output이 잘못됨 (결과값 또는 출력형식의 오류)
2. __test Case Skipped__: time limit 초과로 모든 test case를 프로그램이 접근하지 못함
    - 알고리즘을 __다른 방식으로 다시 풀어야 함__

#### 느낌
- 공부를 더 열심히 해야겠다, 아직 많이 부족함을 느꼈다
- 3시간 안에 1문제 성공적으로 풀고 2번째 문제 코드 다 쓰고서 고쳐나가던 중...
- 일단 시스템 오류만 아니었으면 (오류로 15분 연장되었으나, 끝에 15분에 제출이 되지 않는 오류) 첫 번째 문제는 통과되었을 것...ㅠㅜ
- 시스템 오류로 바로 3번째 문제부터 풂...ㅠㅜ(원래 1,2,3 순서대로 푸는 게 좋은데ㅠㅜ) 그래서 시간이 더 오래걸렸던 듯ㅜㅠ
- 잘하는 분들은 보니까 각자 기본적인 설정 같은 거를 만들어두고서 복사해와 사용하는 것 같다, 나도 만들까?
---
path: "/baekjoon/basic/dynamic_programming/pset"
date: '2019-02-03'
title: "[백준] 풀이 03. 다이나믹 프로그래밍 1"
description: 백준 알고리즘 강의 기초 3강 문제 풀이
image: ''
tags: ['백준', '알고리즘', 'Cpp', '다이나믹프로그래밍', '문제풀이']
---
> 눈 여겨 볼 문제들은 링크가 걸려 있음
> 중요한 유형들은 중요 표시가 되어 있음

__대표유형__:
1. __방법의 수__ 구하기: d[n]이 d[n-1] 또는 d[n-2]등의 합으로 이루어지는 경우
2. __최대값 & 최소값__ 구하기: 
    1. d[n]이 d[n-1] 또는 d[n-2], 그리고 추가적인 입력값 p[n]의 __합으로 이루어지는 경우__ ??
    2. 값들 중 최대값 (d[n]이 결과값이 아닐 수 있음) ??

#### [1로 만들기]
- 문제: 숫자를 1로 만드는 최소 연산의 개수 구하기
- 풀이:
    - x가 3으로 나누어 떨어지면, d[x / 3] + 1 계산
    - x가 2으로 나누어 떨어지면, d[x / 2] + 1 계산
    - 그 외, d[x - 1] + 1 계산
    - 이 세 가지 값 중 가장 min이 되는 값 구하기

#### [2xn 타일링](https://www.acmicpc.net/problem/11726) (중요!)
- 문제 2xn 직사각형을 1x2와 2x1 타일로 채우는 방법의 수 구하기
- 풀이: d[ n] = d[n - 1] + d[n - 2] 계산
    - __타일을 붙일 수 있는 방법__ 에 집중! 
        - 타일을 __세로로 붙이거나__ (2x1), __가로로 붙이는 방법__ (1x2 두개) =>  총 __2 가지의 경우__ 가 존재
        - 이때, (하나를 붙이기와 두개를 붙이기로 경우를 나누지 말 것!)
    - 2x(n-1)에 2x1 타일 가로로 붙이기: d[n - 1]
    - 2x(n-2)에 1x2 타일 세로로 붙이기: d[n - 2]
    - (타일의 개수가 아니라 방법의 수를 구하는 문제이기 때문에 따로 더해야 할 값은 없다)
- __생각의 패러다임__: 사진 참고, 올리기!

#### 2xn 타일링2
- 문제: 2xn 직사각형을 1x2, 2x1, 2x2 타일로 채우는 방법의 수 구하기
- 풀이: 위의 문제와 마찬가지의 방식으로 d[n] = d[n - 1] + 2 * d[n - 2] 계산

#### 1, 2, 3 더하기
- 문제: n의 값을 1, 2, 3의 합을 나타내는 방법의 수 구하기
- 풀이: d[n] = d[n - 1] + d[n - 2] + d[n - 3] 계산
    - 1을 더하는 방법: d[n - 1]
    - 2를 더하는 방법: d[n - 2]
    - 3을 더하는 방법: d[n - 3]

#### [카드팩](https://www.acmicpc.net/problem/11052)
- 문제: 1부터 n개의 카드가 들어있는 카드팩의 가격이 각각 p1부터 pn일 때, n개의 카드를 살 수 있는 최대값 구하기
- 풀이: 
    - 카드 1개 더하기: d[n - 1] + p1
    - 카드 2개 더하기: d[n - 2] + p2
    - ...
    - 카드 n-1개 더하기: d[n - (n-1)] + p(n-1)
    - 카드 n개 더하기: pn
    - 이 중 가장 max가 되는 값 구하기 
    
#### [쉬운 계산 수](https://www.acmicpc.net/problem/10844)
- 문제: 길이가 n인 계단수(인접한 모든 자리수의 차이가 1인 수)의 개수 구하기
- 풀이: 이차원 배열 d[i][j]를 사용하여 숫자의 길이 i마다 j로 끝나는 계단수의 개수 계산
    - d[1][0] = 0, d[1][1]부터 d[1][9]까지의 값은 1로 초기화
    - j == 0 인 경우, 첫번째 자리수가 1인 경우에만 0을 붙일 수 있음: d[i][j] = d[i - 1][j + 1]
    - j == 9 인 경우, 첫번째 자리수가 8인 경우에만 9을 붙일 수 있음: d[i][j] = d[i - 1][j + 1] 
    - 그 외, 첫번째 자리수 앞 뒤의 숫자에 j의 숫자를 붙일 수 있음: d[i][j] = d[i - 1][j + 1] + d[i - 1][j + 1]
    - 마지막으로 d[n][0]부터 d[n][9]까지의 합 구하기

#### 오르막 수
- 문제:
- 풀이:

#### 이친수
- 문제:
- 풀이:

#### [스티커](https://www.acmicpc.net/problem/9465) (중요!)
- 문제: n이 주어졌을 때 2xn의 스티커가 붙어있는 판에서 스티커 점수의 합의 최대값 구하기 (단, 스티커를 떼면, 상하좌우의 스티커는 사용할 수 없음)
- 풀이: 이차원 배열 d[i][j]를 사용하여 i번째 열마다 스티커를 떼는 경우 (0, 1, 2) 각각 최대값 계산
    - __각 열마다 경우의 수를 따져보기__ 
        - 스티커를 떼지 않는 경우: d[i][0]
        - 위 칸 스티커를 떼는 경우: d[i][1]
        - 아래 칸 스티커를 떼는 경우: d[i][2]
    - __각 경우마다 가지수를 따져 그 중 최대값__ 이 나오는 경우 찾기 (해당 경우의 가지수 중 최대값 구하기)
        - 스티커를 떼지 않는 경우, 그 전 열에서 스티커를 떼지 않은 경우, 위 칸 스티커를 떼는 경우, 아래 칸 스티커를 떼는 경우가 있음
        - __해당 경우 중 최대값이 나오는 경우가 이 경우의 최대값이다__
            - d[i][0] = max(d[i - 1][0], d[i - 1][1], d[i - 1][2])
        - 위 칸 스티커를 떼는 경우, 그 전 열에서 스티커를 떼지 않은 경우와 아래 칸 스티커를 떼는 경우가 있음
            - d[n][1] = max(d[n - 1][0], d[n - 1][2]) + p[2][n]
        - 아래 칸 스티커를 떼는 경우, 그 전 열에서 스티커를 떼지 않은 경우와 위 칸 스티커를 떼는 경우가 있음
            - d[n][1] = max(d[n - 1][0], d[n - 1][2]) + p[2][n]

    - __최종 최대값의 경우 찾기__
        - 최대값 = max(d[n][0], d[n][1], d[n][2])
- __생각의 패러다임__: 
    - 그전: 제일 큰 점수 찾아서 최대값에 더하고, 상하좌우로 되어있는 점수를 지워나가기(0으로 설정)
        - 예외적인 경우로 최대값이 나오지 않는 경우가 존재
    - dp: 스티커를 붙이는 _경우의 수_ 를 나누어서 생각. 

#### [포도주 시식](https://www.acmicpc.net/problem/2156) (중요!)
- 문제:
- 풀이: 이차원 배열 d[i][j]를 사용하여 i번째 포도주를 연속으로 마시는 횟수 (0, 1, 2)의 최대값 각각 계산
    - __마시느냐, 안 마시느냐 경우보다는 연속 0, 1, 2번인 경우를 나누어서 생각하기!__
    - d[i][0]: n-1번째 잔을 연속으로 0, 1, 2번 마시는 경우 중 최대값 구하기 
        - d[i][0] = max(d[i - 1][0], d[i - 1][1], d[i - 1][2])
    - d[i][1]: n번째 잔을 연속으로 1번 마신 것이므로, 자동으로 n-1번째 잔은 0번 마신 경우가 됨
        - d[i][0] = d[i - 1][0] + p[i]
    - d[i][2]: n번째 잔을 연속으로 2번 마신 것이므로, 자동으로 n-1번째 잔은 1번 마신 경우가 됨 (n-2번째 잔은 마실 수 없음)
        - d[i][0] = d[i - 1][1] + p[i]

#### [가장 긴 증가하는 부분 수열 (LIS 문제)](https://www.acmicpc.net/problem/11053) (중요!)
- 문제: 수열 N이 주어졌을 때, 가장 긴 증가하는 부분 수열 구하기
- 풀이: 

#### 가장 큰 증가 부분 수열
- 문제:
- 풀이:

#### 가장 긴 감소하는 부분 수열
- 문제:
- 풀이:

#### [가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054)
- 문제:
- 풀이:

#### [연속합](https://www.acmicpc.net/problem/1912)
- 문제: 
- 풀이: 

#### [계단 오르기](https://www.acmicpc.net/problem/2579)
- 문제: 
- 풀이: 

#### [제곱수의 합](https://www.acmicpc.net/problem/1699)
- 문제: 
- 풀이: 

#### [타일 채우기] (중요!)
- 문제: 
- 풀이: 
- __생각의 패러다임__: 그림 참고, 사진 올리기!

#### [파도반 수열]
- 문제: 
- 풀이: 

#### [합분해]
- 문제: 
- 풀이: 

#### [암호코드]
- 문제: 
- 풀이: 

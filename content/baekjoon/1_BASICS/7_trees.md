---
path: "/baekjoon/basic/tree"
date: '2019-05-13'
title: "[백준] 기초 07. 트리 1"
description: 백준 알고리즘 강의 기초 7강 정리
image: ''
tags: ['백준', '백준 기초', '알고리즘', 'Cpp', '트리']
---

### 트리
__사이클이 없는 그래프__ (자료구조의 일종)
- 조건:
    1. __모든 정점이 연결되어 있음__
    2. __정점 V개, 간선 V-1개__

#### # 관계
- 부모 (Parent), 자식 (Children), 형제 (Sibling) 관계가 존재
- 루트 (Root): 부모가 없는 노드
- 단말 정점 (Leaf): 자식이 없는 노드
- __조상 (Ancestor)__: 루트를 넘어가지 않는 선에서 자신의 위에 있는 노드들 (__자기 자신도 포함__)
- __자손 (Decsendent)__: 자신의 밑에 있는 노드들 (__자기 자신도 포함__)

#### # 특성
- __깊이 (Depth / Level)__: 루트에서부터의 거리 (루트 = 0 or 1)
- __높이 (Height)__: 깊이 중 가장 큰 값

####  # 이진 트리 (Binary Tree)
- __자식을 최대 2개만 가지고 있는 트리__

### 트리의 표현
1. 트리도 그래프의 일종이기 때문에, 그래프의 표현과 같은 방식으로 저장할 수 있음
    - 단, 정점 V개에 간선 V-1개이기 때문에 인전행렬보다는 __인접리스트가 더 효율적임__
2. __모든 노드에 부모노드를 저장하는 방식__ 
    - 각 노드마다 부모는 0 또는 1개 밖에 없는 성질 이용 (루트만이 유일하게 부모가 0개)
    - 부모를 찾는데 O(1) but 자식을 찾는데 O(V) 걸림
    - __부모를 찾거나 위로 트리를 탐색하는 경우에 유용__

#### 이진트리의 표현
- __1차원 배열__ 로 표현하여 저장:
    - i번 index 노드의 자식은 왼쪽과 오른쪽 자식으로 (2 * i)와 [(2 * i) + 1] 인덱스에 각각 저장하는 방식
    - 단, 한쪽으로 트리가 쏠려있다면 공간 사용이 매우 비효율적일 수 있음 (최악의 경우 O(2^N)의 공간복잡도)
- __2차원 배열__ 을 사용하여 표현: 
    - A[i][0] & A[i][2] 에 각각 왼쪽/ 오른쪽 자식 저장

### 트리의 순회 (Tree Traversal)
- 트리도 그래프이기 때문에 DFS나 BFS를 사용하여 트리를 순회할 수도 있으나,
- __트리에서만 사용할 수 있는 순회방법이 있음__:
    1. 전위 순회 (Pre-order Traversal)
    2. 중위 순회 (In-order Traversal)
    3. 후위 (Post-order Traversal)
- 세 가지 방법은 노드를 방문을 언제 하느냐의 차이를 가짐

#### (1) 전위 순회 (Preorder Traversal)
__그래프의 DFS와 순서가 같다__
1. 해당 노드 방문
2. 왼쪽 자식 노드를 루트로 하는 서브 트리 프리오더
3. 오르쪽 자식 노드를 루트로 하는 서브 트리 프리오더

#### (2) 중위 순회 (Inorder Traversal)
이진 탐색 트리 (Binary Search Tree)의 Delete를 실행할 때 사용됨
1. 왼쪽 자식 노드를 루트로 하는 서브 트리 인오더
2. 해당 노드 방문
3. 오르쪽 자식 노드를 루트로 하는 서브 트리 인오더

#### (3) 후위 순회 (Postorder Traversal)
__가장 많이 사용되는 순회방법!__ (자식을 먼저 처리하는 방식)
1. 왼쪽 자식 노드를 루트로 하는 서브 트리 프스트오더
2. 오르쪽 자식 노드를 루트로 하는 서브 트리 프스트오더
3. 해당 노드 방문

#### 트리 문제를 푸는 방법
- __트리는 사이클이 없는 그래프임을 명심하자__!
- 트리 성질:
    1. __두 정점 사이의 경로는 1개__
    2. __DFS/BFS 알고리즘으로 나오는 경로는 무조건 최단경로를 보장함__
- 예시: N개 도시, N-1 도로, 모두 연결됨이라는 조건이 주어지면 DFS/BFS를 사용하여 최단경로를 구하면 됨.
- __트리의 부모자식 관계, 깊이, 각 노드의 레벨 등을 전부 DFS/BFS로 풀 수 있음!__

#### [트리의 지름 문제](https://www.acmicpc.net/problem/1167) (중요!)
- 문제: 트리의 두 정점 중 가장 긴 거리를 구하기
- 풀이: 임의의 정점을 루트로 하여 가장 멀리 있는 정점을 구하고, 그 정점을 루트로 하여 가장 멀리 있는 정점과의 거리를 계산
    - __임의의 정점에서 가장 멀리 있는 정점은 원의 지름의 양 끝에 해당하는 두 정점 중 하나가 나오게 됨__
    - 그 정점을 루트로 하면 가장 멀리 있는 정점이 반대편의 지름의 끝에 있는 정점이 되기 때문에 이를 바탕으로 가장 긴 거리를 구할 수 있음
---
path: "/algorithm/baekjoon_basic/dynamic_programming_1"
date: '2018-02-03'
title: "[백준] 강의노트 03. 다이나믹 프로그래밍 1"
description: 백준 알고리즘 강의 기초 3강 정리
image: ''
tags: ['백준', '알고리즘', 'C++', '강의노트', '다이나믹 프로그래밍']
---

### 다이나믹 프로그래밍 (Dynamic Programming)
- __큰 문제를 작은 부분 문제로 나눠서 푸는 알고리즘__.
- dynamic은 사실 아무런 부여 의미가 없음 (멋있어서 이름이 지어졌다는 것은 안 비밀..!)
- 두 가지 속성을 이해해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.
    1. Overlapping Subproblem: 작게 나누어진 부분 문제들이 서로 겹쳐야 한다.
    2. Optimal Substructure: 같은 문제를 구할 때마다 정답이 일정하고 문제의 정답을 작은 문제의 정답으로부터 구할 수 있다.
- 작은 문제들의 정답 기록해 놓고 (Memoization) 다시 사용하는 방법을 이용한다.

#### 피보나치 수 문제로 동적계획 알고리즘 이해하기
- F0 = 0, F1 = 1, FN = FN-1 + FN-2 (N >= 2)
- 문제: N번째 피보나치 수 구하기
- 작은 문제: N-1번째 피보나치 수 구하기, N-2번째 피보나치 수 구하기
- 문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.
```cpp
int d[100];
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    else {
        // memoriazation을 하여 다음에 사용할 수 있게 하기
        if (d[n] > 0) { // 이 부분의 값들이 단순히 양수라서 
            return d[n];
        }
        d[n] = fibonacci(n-1) + fibonacci(n-2);
        return d[n];
    }
}
```

### 다이나믹을 푸는 두 가지 방법 (구현의 차이일 뿐)
1. Top-down: 큰 문제를 점점 작게 만들어나가면서 푸는 방법 
    - 시간복잡도: 메모에 채워야하는 칸의 수 x 1칸을 채우는 복잡도
    - 예) 위의 피보나치 수 구하는 방식 (재귀함수 사용): O(N)
2. Bottom-up: 작은 문제부터 하나도 빠짐없이 차례대로 푸는 방법
    - 시간복잡도: 
    - 예) for문으로 피보나치 수 구하는 방식: O(N)

```cpp
int d[100];
int fibonacci(int n) {
    d[0] = 0;
    d[1] = 1;
    for (int i = 2; i <= n; i++) {
        d[i] = d[i-1] + d[i-2];
    }
    return d[n];
}
```
- top-down 또는 bottom-up 편한대로 사용하면 된다!

### 문제 풀이 전략
d[n] 구하는 방식으로 문제를 이해하기
1. d[i]에 무엇이 들어가야 하는지 파악하여 식 적기
2. n과 n-1, n-2 ... 등의 관계가 어떻게 연결되는지 잘 살펴보기

### 백준 문제 풀이

#### [1로 만들기](https://www.acmicpc.net/problem/1463)
- 문제: 숫자를 1로 만드는 최소 연산의 개수 구하기
- 풀이:
    - x가 3으로 나누어 떨어지면, d[x / 3] + 1 계산
    - x가 2으로 나누어 떨어지면, d[x / 2] + 1 계산
    - 그 외, d[x - 1] + 1 계산
    - 이 세 가지 값 중 가장 min이 되는 값 구하기

#### 2xn 타일링
- 문제 2xn 직사각형을 1x2와 2x1 타일로 채우는 방법의 수 구하기
- 풀이: d[n] = d[n - 1] + d[n - 2] 계산
    - 2x(n-1)에 2x1 타일 하나 붙이기: d[n - 1]
    - 2x(n-2)에 1x2 타일 두 개 붙이기: d[n - 2]
    - (타일의 개수가 아니라 방법을 구하는 문제이기 때문에 따로 더해야 할 값은 없다)

#### 2xn 타일링2
- 문제: 2xn 직사각형을 1x2, 2x1, 2x2 타일로 채우는 방법의 수 구하기
- 풀이: 위의 문제와 마찬가지의 방식으로 d[n] = d[n - 1] + 2 * d[n - 2] 계산

#### 1, 2, 3 더하기
- 문제: n의 값을 1, 2, 3의 합을 나타내는 방법의 수 구하기
- 풀이: d[n] = d[n - 1] + d[n - 2] + d[n - 3] 계산
    - 1을 더하는 방법: d[n - 1]
    - 2를 더하는 방법: d[n - 2]
    - 3을 더하는 방법: d[n - 3]

#### 붕어빵 판매하기
- 문제: 1부터 n개의 카드가 들어있는 카드팩의 가격이 각각 p1부터 pn일 때, n개의 카드를 살 수 있는 최대값 구하기
- 풀이: 
    - 카드 1개 더하기: d[n - 1] + p1
    - 카드 2개 더하기: d[n - 2] + p2
    - 카드 n-1개 더하기: d[n - (n-1)] + p(n-1)
    - 카드 n개 더하기: pn
    - 이 중 가장 max가 되는 값 구하기 
    
#### 쉬운 계산 수
- 문제:
- 풀이:

#### 오르막 수
- 문제:
- 풀이:

#### 이친수
- 문제:
- 풀이:

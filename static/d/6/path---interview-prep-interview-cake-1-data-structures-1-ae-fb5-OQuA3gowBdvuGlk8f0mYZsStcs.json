{"data":{"markdownRemark":{"html":"<blockquote>\n<p><a href=\"https://www.interviewcake.com/article/cpp/data-structures-coding-interview?course=fc1&#x26;section=algorithmic-thinking\">Interview Cake의 Data Structure 파트</a> 정리</p>\n</blockquote>\n<h3>Random Access Memory (RAM)</h3>\n<p><strong>where variables are stored</strong> (a.k.a memory)</p>\n<ul>\n<li>그림</li>\n<li>computers keep track of variables (numbers, strings, arrays, etc.) to run code</li>\n<li>\n<p>structured like <strong>tall bookcase w/ billions of shelves</strong></p>\n<ul>\n<li>each shelf holds 1 byte (8 bits)</li>\n<li>shelf number = address</li>\n</ul>\n</li>\n<li>processors access variables via the <strong>memory controller which has direct access to each shelf (by indexing the address)</strong></li>\n<li>\n<p>processors also <strong>use cache to speed the access time</strong></p>\n<ul>\n<li>cache = storing nearby content of recently accessed addresses</li>\n<li>this makes reading sequential memory faster than jumping around addresses</li>\n</ul>\n</li>\n</ul>\n<h4>RAM (memory) &#x3C;-> Disc (storage)</h4>\n<ul>\n<li><strong>Memory (RAM)</strong>: faster but less space, direct access (by indexing address)</li>\n<li><strong>Storage (Disk)</strong>: slower but more space, no direct access (have to use head on disc)</li>\n</ul>\n<h3>Binary Numbers</h3>\n<p>the number system computers use</p>\n<h4>Fixed-width Integers</h4>\n<ul>\n<li><strong>integer overflow 있을 수 있음</strong></li>\n<li>takes <strong>constant space O(1)</strong></li>\n<li>simple operations take <strong>constant time O(1)</strong></li>\n</ul>\n<h3>Arrays</h3>\n<ul>\n<li>storing same data type in sequential order in memory</li>\n<li><strong>access time: O(1)</strong>, cachable</li>\n<li>constraints: same data type, must be stored in sequenctial order</li>\n</ul>\n<h3>Strings</h3>\n<ul>\n<li>storing series of chars</li>\n</ul>\n<h4>Pointers</h4>\n<ul>\n<li><strong>storing address of data</strong></li>\n<li>\n<p>ex. array of strings (= array of arrays)</p>\n<ul>\n<li>problem: each string may have different length</li>\n<li>solution: store each string in any given space (don't need huge amount of space) then, store the first address of each string in array => pointers</li>\n<li>constraints: not cachable</li>\n</ul>\n</li>\n</ul>\n<h3>Dynamic Arrays</h3>\n<ul>\n<li>problem w/ arrays: have to pre-determine their size</li>\n<li>dynamic arrays <strong>resize arrays when more space is necessary</strong></li>\n</ul>\n<h3>Linked Lists</h3>\n<ul>\n<li><strong>faster prepends/appends O(1)</strong> than dynamic arrays</li>\n<li>but <strong>slower lookups O(n)</strong></li>\n</ul>\n<h3>Hash Tables</h3>\n<ul>\n<li>배열 인덱스 숫자를 통해 값에 접근하는 것처럼</li>\n<li>특정 숫자, 단어 등을 인덱스 <strong>(키 값)</strong> 로 값에 접근할 수 있는 배열처럼 생각하면 됨</li>\n<li>특정 숫자, 단어 등의 키 값을 인덱스로 변환하는 과정을 <strong>hash function</strong>이라고 함</li>\n<li><strong>hash collision 문제 해결 필요</strong></li>\n</ul>","frontmatter":{"title":"Interview Cake - 1. Data Structures","date":"2019-05-10","tags":["Interview Cake","자료구조"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Interview_Prep/Interview_Cake/1_data_structures/"}}
{"data":{"markdownRemark":{"html":"<blockquote>\n<p>Understanding JavaScript</p>\n<ul>\n<li>objects, primitive data types</li>\n<li>based on <a href=\"http://javascript.info/\">tutorial</a></li>\n</ul>\n</blockquote>\n<h3>Objects</h3>\n<p>store <strong>keyed collections</strong> of <strong>various data</strong> and more complex entities</p>\n<ul>\n<li>\n<p><strong>create empty objects</strong></p>\n<pre><code class=\"language-js\">let obj = new Object(); // object constructor\nlet obj = {}; // object literal syntax\n</code></pre>\n</li>\n<li>\n<p><strong>define properties</strong>: <code>key: value</code> pairs</p>\n<pre><code class=\"language-js\">let obj = {\n    name: \"Oh\", \n    age: 15,\n    sayOh() {   // method\n        alert( this.name ); // use 'this'\n    }\n};\n</code></pre>\n<pre><code class=\"language-js\">// if key == value, can use shorthand\nlet obj = { name, age, };\n// { name: name, age: age,}\n</code></pre>\n<ul>\n<li><strong>keys</strong>: <strong>string</strong> or <strong>symbol</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>access properties</strong>: use <code>.</code> or <code>[]</code></p>\n<pre><code class=\"language-js\">obj.isAlphabet = true;    // dot notation\nalert( obj[isAlphabet] ); // bracket notation\n</code></pre>\n<pre><code class=\"language-js\">/* bracket notation is more powerful: \ncan use variables as properties and can create computed properties */\nlet input = prompt(\"Insert an input\", \"default\");\nlet obj = {\n    [input]: 1,\n};\nalert( obj.default ) // access by inputted key\n</code></pre>\n<ul>\n<li>if property name is <strong>simple</strong>, use <strong>dot</strong></li>\n<li>for more <strong>complex</strong>, use <strong>brackets</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>delete properties</strong>: use <code>delete</code> operator</p>\n<pre><code class=\"language-js\">delete obj.age;\n</code></pre>\n</li>\n<li>\n<p><strong>check property exists</strong>: use <code>!== undefined</code> or <code>in</code> operator</p>\n<pre><code class=\"language-js\">// true means that property does not exist\nalert ( obj.noP === undefined );\n// true means property exists\nalert( \"noP\" in obj );\n</code></pre>\n<ul>\n<li><code>in</code> <strong>works better</strong> since a property's value could be set to <code>undefined</code></li>\n</ul>\n</li>\n<li>\n<p><strong>iterate over all keys</strong>: use <code>for</code> and <code>in</code></p>\n<pre><code class=\"language-js\">for (let key in obj) {\n    alert( `${key}: ${obj[key]});\n}\n</code></pre>\n<ul>\n<li>properties are <strong>ordered</strong>: integers are sorted while others are in order of creation</li>\n<li>symbol properties do not appear in for loops bcuz they are hidden properties</li>\n</ul>\n</li>\n</ul>\n<h4>This</h4>\n<p><code>this</code> points to object within the context</p>\n<ul>\n<li>defined at run-time</li>\n<li>arrow functions do not have <code>this</code></li>\n</ul>\n<h4>Copied by Reference</h4>\n<p>objects are stored and copied by reference</p>\n<ul>\n<li>objects store the <strong>address in memory</strong></li>\n<li>properties of objects declared as <code>const</code> <strong>can be changed</strong></li>\n<li>\n<p><strong>cloning/merging an object</strong>: use <code>Object.assign</code></p>\n<pre><code class=\"language-js\">// clone object\nlet copied = Object.assign({},  obj);\n</code></pre>\n<pre><code class=\"language-js\">// merge several objects into one\nlet obj = { name: \"oh\" };\nlet add1 = { canAdd: 1 };\nlet sub1 = { canSub: 2 };\nObject.assign(obj, add1, sub1);\n// obj = { name: oh, canAdd: 1, canSub: 2}\n</code></pre>\n<pre><code class=\"language-js\">// more simply,\nObject.assign(obj, { canAdd: 1, canSub: 2 })\n</code></pre>\n<ul>\n<li>need more sophisticated algorithm for <strong>deep cloning</strong> (<em>to clone objects within objects</em>)</li>\n</ul>\n</li>\n</ul>\n<h3>Garbage Collector</h3>\n<p><strong>monitors all objects</strong> and <strong>removes unreachable objects</strong> for memory management in JavaScript</p>\n<ul>\n<li>\n<p>reachable: values that are accessible or usable somehow</p>\n<pre><code class=\"language-js\">// obj has reference to object (reachable)\nlet obj = { name: \"oh\" };\n/* value object is overwritten\nreference to object is lost (unreachable) */\nobj = null;\n</code></pre>\n<ul>\n<li>reachable = can be referenced from the root somehow</li>\n</ul>\n</li>\n<li>garbage collector <strong>junks the data</strong> and <strong>frees the memory</strong></li>\n</ul>\n<p>think <strong>objects like pointers</strong>:\n- if object variable is overwritten, the actual object value is lost and garbage collector frees the memory\n- if another object variable has reference, the object value is not lost or collected by garbage collector</p>\n<h4>How it works</h4>\n<ul>\n<li>it remembers roots, its references, and its references ...</li>\n<li>in the end, those that were unreachable in this process (objects which do not have links) are removed</li>\n</ul>","frontmatter":{"path":"/javascript/4","title":"JavaScript 4 - Objects","date":"2019-03-20","tags":["웹개발","프론트엔드","JavaScript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}
{"data":{"markdownRemark":{"html":"<blockquote>\n<p>자료구조 중 배열과 상호보완적인 관계를 가지는 링크드 리스트 소개</p>\n</blockquote>\n<h3>연결 리스트 (Linked Lists)</h3>\n<p>동일한 데이터 타입의 노드들이 연속적으로 서로 연결된 자료구조 (sequence of nodes linked together like a chain)</p>\n<p><strong>노드(node)</strong>: 데이터 (data) + 포인터 (pointer)</p>\n<p><strong>연결 리스트(linked list)</strong>: 헤드 포인터 (head pointer)가 가르키는 노드를 시작으로 서로 연결된 노드들</p>\n<ul>\n<li>배열과 달리 연속적인 메모리 공간이 필요하지 않고, 필요에 따라 <strong>크기를 자유롭게 늘리거나 줄일 수 있다</strong>.</li>\n<li>또한, 맨앞 또는 맨뒤에 삽입/삭제해도 노드들을 옮겨야 할 필요가 없기 때문에 <strong>양끝에서의 빠른 삽입 또는 삭제</strong> 가 최대 장점이다 (시간복잡도 <strong>O(1)</strong> 만에 가능)</li>\n<li>그러나 배열과 달리 인덱스가 없어 임의 접근이 불가능하여, <strong>탐색 및 접근이 느린 것</strong> 이 최대 단점이다 (일일이 노드들을 확인해야 되기 때문에 <strong>O(n)</strong> 이 걸린다) </li>\n</ul>\n<h3>연결 리스트의 종류</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">Singly linked lists</th>\n<th align=\"left\">Doubly linked lists</th>\n<th align=\"left\">Doubly + Tail 포인터</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><strong>삽입</strong></td>\n<td align=\"left\">O(n)</td>\n<td align=\"left\">O(n)</td>\n<td align=\"left\">O(n)</td>\n</tr>\n<tr>\n<td align=\"left\">(앞에 삽입: O(1) &#x26; 뒤에 삽입 O(n))</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">- 뒤에 삽입</td>\n<td align=\"left\">O(n)</td>\n<td align=\"left\">O(n)</td>\n<td align=\"left\">O(1)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>삭제</strong></td>\n<td align=\"left\">O(n)</td>\n<td align=\"left\">O(n)</td>\n<td align=\"left\">O(n)</td>\n</tr>\n<tr>\n<td align=\"left\">- 앞에 삭제</td>\n<td align=\"left\">O(1)</td>\n<td align=\"left\">O(1)</td>\n<td align=\"left\">O(1)</td>\n</tr>\n<tr>\n<td align=\"left\">- 뒤에 삭제</td>\n<td align=\"left\">O(n)</td>\n<td align=\"left\">O(n)</td>\n<td align=\"left\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<h4>(1) 단순 연결 리스트 (Singly Linked List)</h4>\n<p><strong>한 방향</strong> 으로만 이어지는 링크드 리스트 (이전 노드로 반대로 돌아가는 방법이 없음)</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// 노드 정의                              // 단순 링크드 리스트 정의</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>                        <span class=\"token operator\">|</span>    <span class=\"token keyword\">class</span> <span class=\"token class-name\">SinglyLinkedList</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span><span class=\"token operator\">:</span>                        <span class=\"token operator\">|</span>        <span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">int</span> data<span class=\"token punctuation\">;</span>                   <span class=\"token operator\">|</span>            Node<span class=\"token operator\">*</span> head<span class=\"token punctuation\">;</span>\n        Node<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>                 <span class=\"token operator\">|</span>        <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>                         <span class=\"token operator\">|</span>            <span class=\"token function\">SinglyLinkedList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>            <span class=\"token operator\">|</span>                <span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>head <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>      <span class=\"token operator\">|</span>            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>   <span class=\"token operator\">|</span>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>                           <span class=\"token operator\">|</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>                                   </code></pre></div>\n<ul>\n<li>\n<p>한 방향으로만 노드들이 이어지기 때문에 <strong>삽입 또는 삭제</strong> 연산을 할 때 <strong>반드시 이전 노드를 기억하고 있어야</strong> 한다. </p>\n<ul>\n<li>그래야만 이전 노드와 다음 노드의 next 포인터를 새로 업데이트할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h4>(2) 이중 연결 리스트 (Doubly Linked List)</h4>\n<p><strong>양방향</strong> 으로 이어지는 링크드 리스트 (이전 노드와 다음 노드 모두 바로 접근 가능)</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// 노드 정의                              // 이중 링크드 리스트 정의 (단순과 동일)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>                        <span class=\"token operator\">|</span>    <span class=\"token keyword\">class</span> <span class=\"token class-name\">DoublyLinkedList</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span><span class=\"token operator\">:</span>                        <span class=\"token operator\">|</span>        <span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">int</span> data<span class=\"token punctuation\">;</span>                   <span class=\"token operator\">|</span>            Node<span class=\"token operator\">*</span> head<span class=\"token punctuation\">;</span>\n        Node<span class=\"token operator\">*</span> prev<span class=\"token punctuation\">;</span>                 <span class=\"token operator\">|</span>        <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n        Node<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>                 <span class=\"token operator\">|</span>            <span class=\"token function\">DoublyLinkedList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>                         <span class=\"token operator\">|</span>                <span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>head <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>            <span class=\"token operator\">|</span>            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>      <span class=\"token operator\">|</span>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>prev <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>   <span class=\"token operator\">|</span>\n            <span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>   <span class=\"token operator\">|</span>\n        <span class=\"token punctuation\">}</span>                           <span class=\"token operator\">|</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>                                   </code></pre></div>\n<ul>\n<li>\n<p>양방향으로 이어지기 때문에 단순 링크드 리스트와 달리, <strong>삽입 또는 삭제</strong> 연산 시에 따로 <strong>이전 노드를 기억하고 있을 필요가 없다</strong> .</p>\n<ul>\n<li>단, 각 노드가 이전 노드를 기록하기 위한 <strong>추가적인 메모리 공간이 사용</strong> 된다.</li>\n<li>더불어서 이전 노드와 다음 노드 각각의 <strong>prev와 next 포인터 모두에 대한 업데이트가 필요</strong> 하다. </li>\n</ul>\n</li>\n</ul>\n<h4>(+) Tail 포인터의 사용</h4>\n<p>링크드 리스트의 <strong>마지막 노드를 가르키는 포인터</strong> (이중 링크드 리스트와 함께 사용하면 좋다)</p>\n<ul>\n<li>헤드 포인터는 링크드 리스트의 노드들을 접근하는데 필수적이나, 테일 포인터는 선택적인 부분이다.</li>\n<li>\n<p>테일 포인터를 사용했을 시에는 링크드 리스트의 <strong>뒤에서의 삽입 또는 삭제</strong> 가 <strong>빨라지는 장점</strong> 이 있다.</p>\n<ul>\n<li>기존에 헤드 포인터만 있었을 때는 마지막 노드 이전 노드까지 탐색해야 했기 때문에 실제로 O(n)의 시간복잡도가 걸렸는데, 테일 포인터가 있을 경우에는 시간복잡도가 O(1)까지도 줄어들 수 있기 때문이다.</li>\n</ul>\n</li>\n<li>\n<p>테일 포인터는 실제로 단순 링크드 리스트보다는 <strong>이중 링크드 리스트에서 더 쓸모가 있다</strong>.</p>\n<ul>\n<li>왜냐하면 테일 포인터가 마지막 노드를 가르키더라도 단순 링크드 리스트의 경우에는 마지막 노드 삭제 시 반드시 이전 노드를 기억하고 있어야 하므로, 결국에는 헤드부터 탐색을 하게 되어 큰 의미가 없기 때문이다.</li>\n<li>즉, 단순 링크드 리스트에서는 테일 포인터의 추가로 뒤에서 삽입은 O(1)이 되나, 뒤에서의 삭제는 그대로 O(n)인 것이다.</li>\n<li>그러나, <strong>이중 링크드 리스트</strong> 에서는 이전 노드를 따로 기억해야 할 필요가 없기 때문에, 테일 포인터의 추가로 <strong>뒤에서의 삽입과 삭제</strong> 는 모두 <strong>O(1)</strong> 으로 줄어드는 효과를 볼 수 있기에 의미가 잇다.</li>\n</ul>\n</li>\n</ul>\n<h3>※ 주의 사항</h3>\n<p>링크드 리스트을 구현하거나 관련 문제를 푸는 경우에 주의해야 할 점들</p>\n<h4>헤드 노드 vs. 다른 노드들</h4>\n<p>링크드 리스트는 인덱스가 없는 자료구조이기 때문에 <strong>항상 헤드(또는 테일) 포인터로만 노드들에 접근</strong> 할 수 있다. 헤드에 연산을 하는 경우에는 바로 실행이 가능하나, <strong>헤드를 제외한 노드</strong> 에서 연산을 하는 경우에는 일단 먼저 <strong>탐색</strong> 을 통해 해당 노드를 찾아야하는 과정이 필요하다. 그렇기 때문에 링크드 리스트에 연산을 하는 경우에는 반드시 <strong>두 가지의 경우</strong> 로 나누어서 생각해야 오류가 나지 않는다.</p>\n<ol>\n<li><strong>헤드 노드</strong> 에 연산 실행하는 경우: O(1)</li>\n<li><strong>헤드를 제외한 다른 노드들</strong> 에 연산을 실행하는 경우: O(n)</li>\n</ol>\n<h4>Hop의 개수</h4>\n<p>링크드 리스트에서 탐색 시 </p>","frontmatter":{"title":"[자료구조] 02. 링크드 리스트","date":"2019-06-07","tags":["자료구조","Cpp"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/CS_Fundamentals/Data_Structures/2_linked_lists/"}}
{"data":{"markdownRemark":{"html":"<blockquote>\n</blockquote>\n<p><a href=\"https://www.geeksforgeeks.org/last-minute-notes-operating-systems/\">https://www.geeksforgeeks.org/last-minute-notes-operating-systems/</a></p>\n<p>커널에 최대한 집중해서 그 부분만 설명할까? *1. 커널 &#x3C;-> 2. 프로세스)\n프로그램 실행 과정 설명에서 프로세스 부분들은 2장으로 옮길까?</p>\n<h3>프로그램 실행 과정</h3>\n<ol>\n<li>\n<p>메모리 로드 (load): 디스크의 파일 시스템에 있는 프로그램 A 파일 -> 메모리 영역(ram)으로 올리기</p>\n<ul>\n<li>프로그램 A의 가상메모리 주소 공간(stack, data, code) 만들어서, 당장 필요한 부분만 메모리에 올리고 (메모리에 올라간 코드 = 프로세스), 나머지는 디스크의 스왑(swap) 영역으로 넣음</li>\n<li>필요에 따라 디스크의 스왑에서 정보를 올렸다 내렸다 함</li>\n</ul>\n</li>\n<li>사용자 모드(user mode)로 모드비트(mode bit)를 설정해두고 자기 코드 실행</li>\n<li>\n<p>만일 코드 실행 중 I/O 작업이 필요한 경우,</p>\n<ol>\n<li>\n<p>trap(소프트웨어 인터럽트의 한 종류)을 사용: </p>\n<ol>\n<li>현 시점의 register와 program count(pc)를 저장하고</li>\n<li>커널 모드(kernel mode, monitor mode, system mode)로 변경한 후 </li>\n<li>\n<p>시스템 콜: 해당 인터럽트의 종류에 해당하는 커널 함수 호출 </p>\n<ul>\n<li>좀 더 구체적으로, 커널 인터럽트 벡터에서 해당 인터럽트에 매칭되는 인터럽트 처리 루틴/인터럽트 핸들러; interrupt service routine 주소를 찾아 해당 함수를 호출하는 것</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>해당 i/o 작업 수행</p>\n<ul>\n<li>i/o 작업 종류에 따라 동기식, 비동기식 i/o가 진행됨</li>\n<li>ex. read 작업 -> 동기식이어야 함 so 프로세스 A 진행은 현재 코드에서 실행이 멈춰있는 상태 (다른 프로세스는 실행이 가능하다; i/o작업은 디바이스 컨트롤러에 맡기고 cpu는 계속 기다리거나, 다른 프로세스 B를 실행할 수도 있음)</li>\n<li>ex. write, thread 작업 -> 비동기식 가능 so 프로세스 A의 i/o 작업과 동시에 그 후의 코드도 실행이 가능 (i/o작업은  디바이스 컨트롤러에 맡기고 cpu는 그 후의 코드를 진행)</li>\n</ul>\n</li>\n<li>\n<p>i/o 완료 시, 디바이스 컨트롤러가 cpu에게 인터럽트(좁은 의미에서의 하드웨어 인터럽트)를 건다</p>\n<ul>\n<li>더 자세히는 사실 너무 큰 정보를 한꺼번에 처리하는 부담을 덜기 위해 중간중간에 디바이스 컨트롤러가 직접적으로 메모리에 block 단위로 i/o 처리 결과들을 전송 (block 단위로 인터럽트가 발생)</li>\n<li>인터럽트를 통해 다시 사용자 모드로 변경되고 프로세스 A 나머지 부분 실행</li>\n<li>?? 비동기식일 경우 그럼 이미 사용자 모드로 넘어왔을텐데, 언제 변경되었는지와 그럴 경우 그럼 3번의 인터럽트는 무슨 역할인가? 디바이스 컨트롤러가 인터럽트를 보냈으면 왜 또 인터럽트를?? </li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p>?? 시스템 콜 &#x3C;-> 인터럽트 처리 코드</p>\n<h3>입출력 실행 과정</h3>\n<h3>중요한 개념들</h3>\n<p>mode bit, interrupt (interrupt, trap), interrupt vector, system call exception, device controller, dma (direct memory access), memory load, kernel memory space</p>\n<p>차라리 커널 주소 공간 먼저 설명하고, 커널 코드가 실행되는 방법 설명할까? 각 커널코드가 실행되는 방법 (시스템 콜, 인터럽트 처리 코드, 자원관리를 위한 코드(cpu 스케줄링, 메모리 관리) 등)</p>\n<p>커널 코드를 완전히 뜯어봐야 되는 것일까...</p>\n<p>위 프로그램 실행 과정에서 부분 커널 주소 공간의 스택과 데이터에 프로세스 관련 데이터가 올라가는 과정도 설명 필요\n마찬가지로 프로그램이 무엇으로 로드가 trigger 되는지도 알고 싶다(\"./program\" 명령어?)</p>\n<p>예시를 통한 설명이 필요 (ex. printf(), scanf() 등이 적힌 프로그램 코드)</p>","frontmatter":{"title":"[OS] 1. 커널","date":"2019-09-26","tags":["운영체제"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/CS_Core/Operating_Systems/1/"}}
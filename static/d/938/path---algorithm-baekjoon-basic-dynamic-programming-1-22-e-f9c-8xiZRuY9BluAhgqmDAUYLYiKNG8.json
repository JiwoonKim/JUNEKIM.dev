{"data":{"markdownRemark":{"html":"<h3>다이나믹 프로그래밍 (Dynamic Programming)</h3>\n<ul>\n<li><strong>큰 문제를 작은 부분 문제로 나눠서 푸는 알고리즘</strong>.</li>\n<li>dynamic은 사실 아무런 부여 의미가 없음 (멋있어서 이름이 지어졌다는 사실!)</li>\n<li>\n<p>두 가지 속성을 이해해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.</p>\n<ol>\n<li><strong>Overlapping Subproblem</strong>: 작게 나누어진 부분 문제들이 서로 겹쳐야 한다.</li>\n<li><strong>Optimal Substructure</strong>: 같은 문제를 구할 때마다 정답이 일정하고 문제의 정답을 작은 문제의 정답으로부터 구할 수 있다.</li>\n</ol>\n</li>\n<li>작은 문제들의 정답 기록해 놓고 (<strong>Memoization</strong>) 다시 사용하는 방법을 이용한다.</li>\n</ul>\n<h4>피보나치 수 문제로 동적계획 알고리즘 이해하기</h4>\n<ul>\n<li>F0 = 0, F1 = 1, FN = FN-1 + FN-2 (N >= 2)</li>\n<li>문제: N번째 피보나치 수 구하기</li>\n<li>작은 문제: N-1번째 피보나치 수 구하기, N-2번째 피보나치 수 구하기</li>\n<li>\n<p>문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> d<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// memoriazation을 하여 다음에 사용할 수 있게 하기</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 값이 존재할 경우 (우연히 양수이기에 조건 사용)</span>\n        <span class=\"token keyword\">return</span> d<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    d<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> d<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3>다이나믹을 푸는 두 가지 방법 (구현의 차이일 뿐)</h3>\n<ol>\n<li>\n<p><strong>Top-down</strong>: 큰 문제를 점점 작게 만들어나가면서 푸는 방법 </p>\n<ul>\n<li>시간복잡도: 메모에 채워야하는 칸의 수 x 1칸을 채우는 복잡도</li>\n<li>ex) 위의 피보나치 수 구하는 방식 (재귀함수 사용): O(N)</li>\n</ul>\n</li>\n<li>\n<p><strong>Bottom-up</strong>: 작은 문제부터 하나도 빠짐없이 차례대로 푸는 방법</p>\n<ul>\n<li>시간복잡도: 위와 동일</li>\n<li>ex) for문으로 피보나치 수 구하는 방식: O(N)</li>\n</ul>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> d<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    d<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    d<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> d<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> d<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>top-down 또는 bottom-up <strong>편한대로 사용</strong> 하면 된다!</li>\n</ul>\n<h3>문제 풀이 전략</h3>\n<p><strong>d[n] 구하는 방식</strong> 으로 문제를 이해하기</p>\n<ol>\n<li><strong>d[i]에 무엇이 들어가야 하는지 파악</strong> 하여 식 적기 </li>\n<li>\n<p>d[n]과 d[n-1] 등의 관계가 어떻게 연결되는지 잘 살펴보기</p>\n<ul>\n<li>단순히 d[n]과 d[n-1]의 패턴을 고려할 것이 아니라,</li>\n<li><em>문제에서 주어지는 조건들을 가지고 어떻게 d[n]을 만들어나갈 수 있는지 초점을 맞출 것!</em></li>\n<li>\n<p>ex. 쉬운 계단 수 문제</p>\n<ul>\n<li>fail: d[n] = 2 * d[n-1] - (n-1) 방식으로 패턴을 만들어나가기 (그냥 운좋게 처음 d[1], d[2], d[3], d[4]까지는 맞으나, 그 후부터는 틀림.</li>\n<li>correct: 1~9를 숫자길이가 하나 짧은 숫자에 붙여나가는 패턴 사용하면 (문제 풀이 방식 참고)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>경우의 수가 나누어져서 따져야 하는 경우</strong>, <strong>이차원 배열 d[n][i]를 사용</strong> 하여 n번째마다 경우의 수 i를 각각 기록하는 방식 사용하기</li>\n<li><strong>최대 or 최소값</strong> 구하는 문제의 경우, 경우의 수를 따지고 그 중 </li>\n</ol>\n<h3>백준 문제 풀이</h3>\n<blockquote>\n<p>눈 여겨 볼 문제들은 링크가 걸려 있음\n중요한 유형들은 중요 표시가 되어 있음</p>\n</blockquote>\n<p><strong>대표유형</strong>:</p>\n<ol>\n<li><strong>방법의 수</strong> 구하기: d[n]이 d[n-1] 또는 d[n-2]등의 합으로 이루어지는 경우</li>\n<li>\n<p><strong>최대값 &#x26; 최소값</strong> 구하기: </p>\n<ol>\n<li>d[n]이 d[n-1] 또는 d[n-2], 그리고 추가적인 입력값 p[n]의 <strong>합으로 이루어지는 경우</strong> ??</li>\n<li>값들 중 최대값 (d[n]이 결과값이 아닐 수 있음) ??</li>\n</ol>\n</li>\n</ol>\n<h4>1로 만들기</h4>\n<ul>\n<li>문제: 숫자를 1로 만드는 최소 연산의 개수 구하기</li>\n<li>\n<p>풀이:</p>\n<ul>\n<li>x가 3으로 나누어 떨어지면, d[x / 3] + 1 계산</li>\n<li>x가 2으로 나누어 떨어지면, d[x / 2] + 1 계산</li>\n<li>그 외, d[x - 1] + 1 계산</li>\n<li>이 세 가지 값 중 가장 min이 되는 값 구하기</li>\n</ul>\n</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/11726\">2xn 타일링</a> (중요!)</h4>\n<ul>\n<li>문제 2xn 직사각형을 1x2와 2x1 타일로 채우는 방법의 수 구하기</li>\n<li>\n<p>풀이: d[n] = d[n - 1] + d[n - 2] 계산</p>\n<ul>\n<li>\n<p><strong>타일을 붙일 수 있는 방법</strong> 에 집중! </p>\n<ul>\n<li>타일을 <strong>세로로 붙이거나</strong> (2x1), <strong>가로로 붙이는 방법</strong> (1x2 두개) =>  총 <strong>2 가지의 경우</strong> 가 존재</li>\n<li>이때, (하나를 붙이기와 두개를 붙이기로 경우를 나누지 말 것!)</li>\n</ul>\n</li>\n<li>2x(n-1)에 2x1 타일 가로로 붙이기: d[n - 1]</li>\n<li>2x(n-2)에 1x2 타일 세로로 붙이기: d[n - 2]</li>\n<li>(타일의 개수가 아니라 방법의 수를 구하는 문제이기 때문에 따로 더해야 할 값은 없다)</li>\n</ul>\n</li>\n<li><strong>생각의 패러다임</strong>: 사진 참고, 올리기!</li>\n</ul>\n<h4>2xn 타일링2</h4>\n<ul>\n<li>문제: 2xn 직사각형을 1x2, 2x1, 2x2 타일로 채우는 방법의 수 구하기</li>\n<li>풀이: 위의 문제와 마찬가지의 방식으로 d[n] = d[n - 1] + 2 * d[n - 2] 계산</li>\n</ul>\n<h4>1, 2, 3 더하기</h4>\n<ul>\n<li>문제: n의 값을 1, 2, 3의 합을 나타내는 방법의 수 구하기</li>\n<li>\n<p>풀이: d[n] = d[n - 1] + d[n - 2] + d[n - 3] 계산</p>\n<ul>\n<li>1을 더하는 방법: d[n - 1]</li>\n<li>2를 더하는 방법: d[n - 2]</li>\n<li>3을 더하는 방법: d[n - 3]</li>\n</ul>\n</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/11052\">카드팩</a></h4>\n<ul>\n<li>\n<p>문제: 1부터 n개의 카드가 들어있는 카드팩의 가격이 각각 p1부터 pn일 때, n개의 카드를 살 수 있는 최대값 구하기</p>\n</li>\n<li>\n<p>풀이: </p>\n<ul>\n<li>카드 1개 더하기: d[n - 1] + p1</li>\n<li>카드 2개 더하기: d[n - 2] + p2</li>\n<li>...</li>\n<li>카드 n-1개 더하기: d[n - (n-1)] + p(n-1)</li>\n<li>카드 n개 더하기: pn</li>\n<li>이 중 가장 max가 되는 값 구하기 </li>\n</ul>\n</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/10844\">쉬운 계산 수</a></h4>\n<ul>\n<li>문제: 길이가 n인 계단수(인접한 모든 자리수의 차이가 1인 수)의 개수 구하기</li>\n<li>\n<p>풀이: 이차원 배열 d[i][j]를 사용하여 숫자의 길이 i마다 j로 끝나는 계단수의 개수 계산</p>\n<ul>\n<li>d[1][0] = 0, d[1][1]부터 d[1][9]까지의 값은 1로 초기화</li>\n<li>j == 0 인 경우, 첫번째 자리수가 1인 경우에만 0을 붙일 수 있음: d[i][j] = d[i - 1][j + 1]</li>\n<li>j == 9 인 경우, 첫번째 자리수가 8인 경우에만 9을 붙일 수 있음: d[i][j] = d[i - 1][j + 1] </li>\n<li>그 외, 첫번째 자리수 앞 뒤의 숫자에 j의 숫자를 붙일 수 있음: d[i][j] = d[i - 1][j + 1] + d[i - 1][j + 1]</li>\n<li>마지막으로 d[n][0]부터 d[n][9]까지의 합 구하기</li>\n</ul>\n</li>\n</ul>\n<h4>오르막 수</h4>\n<ul>\n<li>문제:</li>\n<li>풀이:</li>\n</ul>\n<h4>이친수</h4>\n<ul>\n<li>문제:</li>\n<li>풀이:</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/9465\">스티커</a> (중요!)</h4>\n<ul>\n<li>\n<p>문제: n이 주어졌을 때 2xn의 스티커가 붙어있는 판에서 스티커 점수의 합의 최대값 구하기 (단, 스티커를 떼면, 상하좌우의 스티커는 사용할 수 없음)</p>\n</li>\n<li>\n<p>풀이: 이차원 배열 d[i][j]를 사용하여 i번째 열마다 스티커를 떼는 경우 (0, 1, 2) 각각 최대값 계산</p>\n<ul>\n<li>\n<p><strong>각 열마다 경우의 수를 따져보기</strong> </p>\n<ul>\n<li>스티커를 떼지 않는 경우: d[i][0]</li>\n<li>위 칸 스티커를 떼는 경우: d[i][1]</li>\n<li>아래 칸 스티커를 떼는 경우: d[i][2]</li>\n</ul>\n</li>\n<li>\n<p><strong>각 경우마다 가지수를 따져 그 중 최대값</strong> 이 나오는 경우 찾기 (해당 경우의 가지수 중 최대값 구하기)</p>\n<ul>\n<li>스티커를 떼지 않는 경우, 그 전 열에서 스티커를 떼지 않은 경우, 위 칸 스티커를 떼는 경우, 아래 칸 스티커를 떼는 경우가 있음</li>\n<li>\n<p><strong>해당 경우 중 최대값이 나오는 경우가 이 경우의 최대값이다</strong></p>\n<ul>\n<li>d[i][0] = max(d[i - 1][0], d[i - 1][1], d[i - 1][2])</li>\n</ul>\n</li>\n<li>\n<p>위 칸 스티커를 떼는 경우, 그 전 열에서 스티커를 떼지 않은 경우와 아래 칸 스티커를 떼는 경우가 있음</p>\n<ul>\n<li>d[n][1] = max(d[n - 1][0], d[n - 1][2]) + p[2][n]</li>\n</ul>\n</li>\n<li>\n<p>아래 칸 스티커를 떼는 경우, 그 전 열에서 스티커를 떼지 않은 경우와 위 칸 스티커를 떼는 경우가 있음</p>\n<ul>\n<li>d[n][1] = max(d[n - 1][0], d[n - 1][2]) + p[2][n]</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>최종 최대값의 경우 찾기</strong></p>\n<ul>\n<li>최대값 = max(d[n][0], d[n][1], d[n][2])</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>생각의 패러다임</strong>: </p>\n<ul>\n<li>\n<p>그전: 제일 큰 점수 찾아서 최대값에 더하고, 상하좌우로 되어있는 점수를 지워나가기(0으로 설정)</p>\n<ul>\n<li>예외적인 경우로 최대값이 나오지 않는 경우가 존재</li>\n</ul>\n</li>\n<li>dp: 스티커를 붙이는 <em>경우의 수</em> 를 나누어서 생각. </li>\n</ul>\n</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/2156\">포도주 시식</a> (중요!)</h4>\n<ul>\n<li>문제:</li>\n<li>\n<p>풀이: 이차원 배열 d[i][j]를 사용하여 i번째 포도주를 연속으로 마시는 횟수 (0, 1, 2)의 최대값 각각 계산</p>\n<ul>\n<li><strong>마시느냐, 안 마시느냐 경우보다는 연속 0, 1, 2번인 경우를 나누어서 생각하기!</strong></li>\n<li>\n<p>d[i][0]: n-1번째 잔을 연속으로 0, 1, 2번 마시는 경우 중 최대값 구하기 </p>\n<ul>\n<li>d[i][0] = max(d[i - 1][0], d[i - 1][1], d[i - 1][2])</li>\n</ul>\n</li>\n<li>\n<p>d[i][1]: n번째 잔을 연속으로 1번 마신 것이므로, 자동으로 n-1번째 잔은 0번 마신 경우가 됨</p>\n<ul>\n<li>d[i][0] = d[i - 1][0] + p[i]</li>\n</ul>\n</li>\n<li>\n<p>d[i][2]: n번째 잔을 연속으로 2번 마신 것이므로, 자동으로 n-1번째 잔은 1번 마신 경우가 됨 (n-2번째 잔은 마실 수 없음)</p>\n<ul>\n<li>d[i][0] = d[i - 1][1] + p[i]</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/11053\">가장 긴 증가하는 부분 수열 (LIS 문제)</a> (중요!)</h4>\n<ul>\n<li>문제: 수열 N이 주어졌을 때, 가장 긴 증가하는 부분 수열 구하기</li>\n<li>풀이: </li>\n</ul>\n<h4>가장 큰 증가 부분 수열</h4>\n<ul>\n<li>문제:</li>\n<li>풀이:</li>\n</ul>\n<h4>가장 긴 감소하는 부분 수열</h4>\n<ul>\n<li>문제:</li>\n<li>풀이:</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/11054\">가장 긴 바이토닉 부분 수열</a></h4>\n<ul>\n<li>문제:</li>\n<li>풀이:</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/1912\">연속합</a></h4>\n<ul>\n<li>문제: </li>\n<li>풀이: </li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/2579\">계단 오르기</a></h4>\n<ul>\n<li>문제: </li>\n<li>풀이: </li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/1699\">제곱수의 합</a></h4>\n<ul>\n<li>문제: </li>\n<li>풀이: </li>\n</ul>\n<h4>[타일 채우기] (중요!)</h4>\n<ul>\n<li>문제: </li>\n<li>풀이: </li>\n<li><strong>생각의 패러다임</strong>: 그림 참고, 사진 올리기!</li>\n</ul>\n<h4>[파도반 수열]</h4>\n<ul>\n<li>문제: </li>\n<li>풀이: </li>\n</ul>\n<h4>[합분해]</h4>\n<ul>\n<li>문제: </li>\n<li>풀이: </li>\n</ul>\n<h4>[암호코드]</h4>\n<ul>\n<li>문제: </li>\n<li>풀이: </li>\n</ul>","frontmatter":{"path":"/algorithm/baekjoon_basic/dynamic_programming_1","title":"[백준] 강의노트 03. 다이나믹 프로그래밍 1","date":"2018-02-03","tags":["백준","알고리즘","C++","강의노트","다이나믹 프로그래밍"]}}},"pageContext":{}}
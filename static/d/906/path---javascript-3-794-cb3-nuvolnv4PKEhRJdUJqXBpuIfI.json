{"data":{"markdownRemark":{"html":"<blockquote>\n<p>Understanding JavaScript</p>\n<ul>\n<li>based on <a href=\"http://javascript.info/\">tutorial</a></li>\n</ul>\n</blockquote>\n<h3>Primitive Data Types</h3>\n<p>single valued data types</p>\n<ul>\n<li>6 types: <strong>numbers</strong>, <strong>strings</strong>, <strong>boolean</strong>, <strong>null</strong>, <strong>undefined</strong>, and <strong>symbols</strong></li>\n</ul>\n<h4>Primitive Methods</h4>\n<ul>\n<li>JavaScript creates <strong>object wrappers</strong> when <strong>numbers, strings, booleans and symbols</strong> are accessed by <code>.</code> to allow extra functionalities such as <strong>methods and properties</strong></li>\n<li>the wrapper (a.k.a String, Number, Boolean, Symbol) is different for each primitive type; provide different methods</li>\n<li>the wrapper is destroyed right after it is used</li>\n</ul>\n<h3>1. Numbers</h3>\n<ul>\n<li>\n<p>use <code>e</code> to specify zero count</p>\n<pre><code class=\"language-js\">let million = 1e6; // 1000,000\nlet milli = 1e-3; // 0.001\n</code></pre>\n</li>\n</ul>\n<h4>Conversion</h4>\n<ul>\n<li>\n<p><strong>to Number</strong>: <code>+</code> or <code>Number()</code>, </p>\n<ul>\n<li><code>parseInt()</code> &#x26; <code>parseFloat()</code>: to convert and parse</li>\n</ul>\n</li>\n<li>\n<p><strong>from Number</strong>: <code>.toString()</code></p>\n<pre><code class=\"language-js\">let num = 255;\nnum.toString();  // \"255\"\nnum.toString(2); // \"11111111\"\n100..toString(); (100).toString(); // to use directly on value\n</code></pre>\n</li>\n</ul>\n<h4>Rounding</h4>\n<ul>\n<li>\n<p>Rounding to <strong>Integers</strong>: <code>Math.floor()</code>, <code>Math.ceil()</code>, <code>Math.round()</code>, <code>Math.trunc()</code></p>\n</li>\n<li>\n<p>Rounding to <strong>Floating-point values</strong>:</p>\n<pre><code class=\"language-js\">let num = 3.145;\n// rounds to n digits after the point, returns string\n// then, must convert it back to number type\n+num.toFixed(2); // 3.145 -> \"3.14\" -> 3.14\n</code></pre>\n</li>\n</ul>\n<h4>Imprecison</h4>\n<p>since floating-point values are actually represented as endless fractions in binary form, they produce imprecise calculations. <strong>So Beware!</strong> </p>\n<ul>\n<li>can use <code>.toFixed()</code> to round result into desired outcome and lose imprecise calculations</li>\n</ul>\n<h4>Other Math Functions</h4>\n<ul>\n<li><code>Math.random()</code>: returns random number from 0 to 1</li>\n<li><code>Math.max()</code> &#x26; <code>Math.min()</code>: returns max/min from number or arguments</li>\n<li><code>**</code>: returns n^power</li>\n</ul>\n<h3>2. Strings</h3>\n<p>textual data encoded in UTF-16</p>\n<ul>\n<li><code>.length</code>: return length of string</li>\n<li><code>.toLowerCase()</code> &#x26; <code>.toUpperCase()</code>: convert to lower/uppercase</li>\n</ul>\n<h4>Substrings</h4>\n<ul>\n<li>find position of substring: <code>.indexOf()</code></li>\n<li>checks containing of substring: <code>.includes()</code>, <code>.startsWith()</code>, <code>.endsWith()</code></li>\n<li>return a substring: <code>.slice()</code>, <code>.substring()</code></li>\n</ul>\n<h4>Comparison</h4>\n<ul>\n<li>use <code>localeCompare</code>, otherwise they are compared by character codes</li>\n</ul>\n<h3>3. Boolean</h3>\n<p><code>true</code> or <code>false</code></p>\n<h3>4. Null</h3>\n<p><strong>nothing, empty, value unknown</strong></p>\n<ul>\n<li><code>null</code>:used to assign an empty or unkown value to variable</li>\n</ul>\n<h3>5. Undefined</h3>\n<p><strong>value is not assigned</strong></p>\n<ul>\n<li><code>undefined</code>: used to check if variable has been assigned a value</li>\n</ul>\n<h3>6. Symbols</h3>\n<p>primitive type for unique identifiers</p>\n<pre><code class=\"language-js\">let s = Symbol();\n</code></pre>\n<ul>\n<li>symbols are <strong>always unique</strong> even if they have the same name</li>\n<li><strong>used to create hidden properties for objects</strong></li>\n<li>symbol -> string: need to use <code>.toString()</code> (do not auto-convert)</li>\n<li>\n<p><strong>global symbols</strong>: symbols that can access the same value</p>\n<ul>\n<li>same-named symbols are equal in global registry</li>\n<li>\n<p>use <code>Symbol.for(__name__)</code></p>\n<pre><code class=\"language-js\">// s === ss\nlet s = Symbol.for(\"id\"); // create if not exists\nlet ss = Symbol.for(\"id\");\n</code></pre>\n</li>\n<li><code>Symbol.keyFor(__symVar__)</code>: returns symbol name</li>\n</ul>\n</li>\n</ul>\n<h4>System Symbols</h4>\n<p>system symbols JavaScript uses internally, can be used to fine-tune various various aspects of objects</p>\n<ul>\n<li><code>Symbol.hasInstance</code>, <code>Symbol.isConcatSpreadable</code>, <code>Symbol.iterator</code>, <code>Symbol.toPrimitive</code>, etc.</li>\n</ul>","frontmatter":{"path":"/javascript/3","title":"JavaScript 3 - Primitive Data Types","date":"2019-03-20","tags":["웹개발","프론트엔드","JavaScript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}
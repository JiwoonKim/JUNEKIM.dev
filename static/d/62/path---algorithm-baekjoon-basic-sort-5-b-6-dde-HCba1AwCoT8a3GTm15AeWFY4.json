{"data":{"markdownRemark":{"html":"<h3>정렬</h3>\n<p><strong>어떤 자료를 순서대로 배열하는 것</strong></p>\n<ul>\n<li>\n<p>다양한 방식이 존재: 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 힙 정렬, 병합 정렬, etc.</p>\n<ul>\n<li>O(n^2)과 O(nlogn)으로 크게 나누어진다.</li>\n</ul>\n</li>\n<li>빠를수록 좋기에 <strong>O(nlogn)인 퀵 정렬, 힙 정렬, 병합 정렬을 주로 사용</strong> 한다.</li>\n<li>\n<p><strong>직접 구현하기보다는 STL에 있는 <code class=\"language-text\">sort</code> 함수를 사용</strong> 하는 것이 좋다.</p>\n<ul>\n<li><code class=\"language-text\">sort(begin, end)</code>: begin부터 end 바로 전까지를 정렬</li>\n</ul>\n</li>\n</ul>\n<h3>퀵 정렬 (Quick Sort) 구현</h3>\n<ul>\n<li><strong>O(N*logN)</strong> 의 시간복잡도를 가지는 <strong>분할정복 알고리즘</strong> 이다.</li>\n<li>\n<p><strong>기준 값을 중심으로 계속 배열을 나누어나가는 방법</strong> 이다.</p>\n<ul>\n<li>기준 값을 중심으로 나누기 때문에 합치는 부분은 필요 X</li>\n</ul>\n</li>\n<li>\n<p>크게 두 부분으로 나누어 구현:</p>\n<ol>\n<li>\n<p><strong>Partition</strong>: pivot을 기준으로 <strong>두 부분으로 나누기</strong></p>\n<ul>\n<li>pivot 값을 정한 후, <strong>배열의 끝으로 위치</strong> 시킴으로써 그 전값들과 값 비교가 용이하게 하기</li>\n<li>모든 값 비교 후, pivot보다 <strong>작은 값들 다음 인덱스로 다시 pivot 값 위치시키기</strong></li>\n<li>왼쪽은 pivot보다 작은 값들, 오른쪽은 더 큰 값들의 결과가 나온다 (<strong>단, 각각 부분이 정렬된 상태 X</strong>)</li>\n</ul>\n</li>\n<li>\n<p><strong>Quicksort Recursion</strong>: 나누어진 두 부분을 각각 다시 partition한 후 quicksort</p>\n<ul>\n<li>배열의 원소가 하나일 때까지 partition하여 quicksort 실행</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>swap 함수를 별도로 정의하여 사용하면 편리</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> lowIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> highIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 값이 두 개 이상인 배열만 partition하여 quicksort 실행</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>highIndex <span class=\"token operator\">></span> lowIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// partition하기</span>\n        <span class=\"token keyword\">int</span> pivotIndex <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>lowIndex<span class=\"token punctuation\">,</span> highIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 나누어진 두 부분에 대해 각각 quicksort 다시 실행</span>\n        <span class=\"token comment\">// pivot 값은 그대로 냅두고 이를 제외한 두 부분을 정렬 (재귀)</span>\n        <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>lowIndex<span class=\"token punctuation\">,</span> pivotIndex <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>pivotIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> highIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> lowIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> highIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Pivot을 정하여 그 값을 배열 끝자리(highIndex)로 옮기기</span>\n    <span class=\"token comment\">// 그래야 lowIndex ~ highIndex 전까지의 값들과 pivot 값 비교가 쉬움</span>\n    <span class=\"token keyword\">int</span> pivotIndex <span class=\"token operator\">=</span> low <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>highIndex <span class=\"token operator\">-</span> lowIndex<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>pivotIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>highIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 다른 값들과 pivot값 (@highIndex) 비교함으로써 배열을 둘로 나누기</span>\n    <span class=\"token keyword\">int</span> leftEndIndex <span class=\"token operator\">=</span> lowIndex<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> lowIndex<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> highIndex<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>highIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>leftEndIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            leftEndIndex <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 마지막으로 왼쪽 배열 다음 값으로 pivot 값 옮기기</span>\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>highIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>leftEndIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// pivot 값이 위치한 인덱스 반환</span>\n    <span class=\"token keyword\">return</span> leftEndIndex<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">/* 직접적으로 함수에 배열을 전달하는 방법은 함수 호출할 때마다 \n배열의 형태를 고려해야하는 번거로움이 있기 때문에 swap이 편리함 */</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n    a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n    b <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3>병합 정렬 (Merge Sort) 구현</h3>\n<ul>\n<li><strong>O(N*logN)</strong> 의 시간복잡도를 가지는 <strong>분할정복 알고리즘</strong> 이다.</li>\n<li><strong>배열을 무조건 반으로 계속 나눈 후 합치면서 정렬해나가는 방법</strong> 이다.</li>\n<li>\n<p>크게 두 부분으로 나누어 구현:</p>\n<ol>\n<li><strong>Divide</strong>:  원소가 하나 남은 상태일 때까지 <strong>계속 배열을 반으로 나누기</strong></li>\n<li>\n<p><strong>Merge</strong>: 나누어진 두 배열의 원소들을 <strong>차례대로 비교하면서 하나의 배열로 합치기</strong>; <strong>합치는 과정에서 정렬</strong></p>\n<ul>\n<li>두 배열을 합치는 과정에서만 원소 간 비교가 필요하며, 합친 결과는 임시 배열에 저장</li>\n<li>비교 후 한 쪽 배열에 원소가 남아있다면, 그대로 원소들을 차례대로 옮기기</li>\n<li>마지막으로 임시적으로 합친 배열을 <strong>다시 원래 배열으로 옮겨 저장</strong></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>값들을 합치는 과정을 일시적으로 저장할 temporary 배열을 사용하기</strong> </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// a 배열에 있는 값들을 나누어나가고 </span>\n<span class=\"token comment\">// 합치면서 정렬한 결과를 b 배열에 저장</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> merged<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//  원소가 하나일 경우, 그대로 냅두기</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">==</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 원소가 하나만 있을 때까지, 배열을 반으로 나누기</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 두 배열을 합치기 (이 과정에서 정렬이 됨)</span>\n    <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 배열 merged의 인덱스를 track해 나갈 변수 정의</span>\n    <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 나누어진 두 배열 각각의 시작점부터 차례대로 원소들 비교해나가기</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> leftTurn <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> rightTurn <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>leftTurn <span class=\"token operator\">&lt;=</span> mid <span class=\"token operator\">&amp;&amp;</span> rightTurn <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 비교 결과 더 작은 값을 merged 배열에 저장</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>leftTurn<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> a<span class=\"token punctuation\">[</span>rightTurn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            merged<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>leftTurn<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            merged<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>rightTurn<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 비교하는 두 배열 중 merged로 옮겨지지 않은 원소가 있을 경우, 차례대로 옮기기 </span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>leftTurn <span class=\"token operator\">&lt;=</span> mid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        merged<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>leftTurn<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>rightTurn <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        merged<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>rightTurn<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 마지막으로, merged 된 배열의 값들을 다시 a 배열로 옮긴다 (overwrite)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> merged<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3>퀵 정렬과 병합 정렬 비교</h3>\n<ul>\n<li><strong>공통점</strong>: <strong>O(N * logN)의 시간복잡도</strong>, <strong>분할정복 알고리즘</strong> 에 기반한다.</li>\n<li>\n<p><strong>차이점</strong>:</p>\n<ul>\n<li>퀵 정렬: 기준값을 가지고 배열을 나누어나가기 때문에, <strong>나누어나가는 과정에서 정렬</strong> 이 된다. (따로 병합 과정이 필요 X; 있는 그대로 이어붙이면 정렬된 상태)</li>\n<li>병합 정렬: 무조건 반으로 배열을 나누어나가기 때문에, 나누어진 두 배열의 값들을 하나하나 비교하면서 정렬해야 한다. 결국, <strong>병합하는 과정에서 정렬</strong> 이 된다.</li>\n</ul>\n</li>\n</ul>\n<h3>버블 정렬 (Bubble Sort) 구현하기</h3>\n<ul>\n<li><strong>O(N^2)</strong> 의 시간복잡도를 가지는 알고리즘이다.</li>\n<li>완전히 정렬된 상태일 때까지 인접한 두 원소를 비교해나가면 swap를 진행하는 방법이다 (N * N).</li>\n<li>\n<p>구현:</p>\n<ul>\n<li>배열의 원소 개수만큼 루프 (N 패스)를 돌며 인접한 두 원소를 비교해가며 swap를 실행</li>\n<li>그 결과, 한 패스마다 <strong>차례대로 가장 큰 숫자가 끝으로 옮겨지고 나머지는 그 차례 그대로 유지됨</strong></li>\n<li>그렇기 때문에 <strong>각 패스는 0 ~ (n - 패스차례) 만큼만 swap를 실행하면 됨</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>swap 함수를 별도로 정의하여 사용하면 편리</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 배열의 각 원소 개수만큼 루프를 돌며 (N 패스 돌기)</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">bool</span> change <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 인접한 두 원소를 비교하여 swap (정렬)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">-</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> v<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            change <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 배열이 모두 정렬된 상태이면, 루프 종료시키기</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>change <span class=\"token operator\">==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3>특별한 조건으로 정렬</h3>\n<h4>특수한 자료를 정렬해야 할 때</h4>\n<p>기본자료형 (정수, 문자열, etc.)가 아닌 자료를 정렬해야 할 때</p>\n<ol>\n<li>STL 자료형을 변형하여 사용 가능하다.</li>\n<li>\n<p><strong>구조체(struct)로 정의하여 사용할 수 있다</strong> (cmp 함수를 연산자 오버로딩을 할 수도 있음)</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> Point <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 연산자 오버로딩하여 구현</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span> <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Point <span class=\"token operator\">&amp;</span>v<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> x <span class=\"token operator\">&lt;</span> v<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ol>\n<h4>특별한 조건을 기반으로 정렬해야 할 때:</h4>\n<ul>\n<li>\n<p><strong>cmp 함수</strong> 를 조건에 맞춰 따로 정의한 후 <code class=\"language-text\">sort(start, end, cmp)</code>을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> cmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">cmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> u <span class=\"token operator\">&lt;</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// u &lt; v가 true인 경우, u가 v보다 앞에 옴</span>\n<span class=\"token comment\">// false인 경우 (u > v), u가 v보다 뒤에 옴</span></code></pre></div>\n</li>\n<li>\n<p>람다함수를 정의하여 바로 사용도 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> u <span class=\"token operator\">&lt;</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<h4>조건이 여러 개 중첩되는 경우</h4>\n<ul>\n<li>if 조건문을 여러번 중첩시킬 경우, 실수할 확률이 커지기 때문에</li>\n<li>\n<p>대신, <strong>cmp 함수내에 pair나 tuple을 사용</strong> 하여 간단하게 정렬한다.</p>\n<ul>\n<li><code class=\"language-text\">make_tuple() &lt; make_tuple()</code>을 return 하는 방식 </li>\n<li>증가하는 경우를 위해 <code class=\"language-text\">&lt;</code>로 비교</li>\n<li>감소하는 경우를 위해 tuple 내의 field 변수에 <code class=\"language-text\">-</code>를 양쪽에 추가</li>\n</ul>\n</li>\n<li>\n<p>이렇게 하면 <strong>한번에 비교를 하기 용이</strong> 하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// age는 감소하는 순서대로, score는 증가하는 순서대로 정렬</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">cmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Person <span class=\"token operator\">&amp;</span>u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Person <span class=\"token operator\">&amp;</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_tuple</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>u<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">.</span>score<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token function\">make_tuple</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>v<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span>score<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3>안정 정렬 (Stable Sorting)</h3>\n<ul>\n<li><strong>같은 것이 있는 경우에 정렬하기 전의 순서가 유지되는 정렬 알고리즘</strong> 이다.</li>\n<li><strong>병합정렬(Merge Sort)</strong> 와 <strong>버블 소트(Bubble Sort)</strong> 가 정렬 알고리즘에 해당한다.</li>\n<li>\n<p>STL에는 <code class=\"language-text\">stable_sort</code> 알고리즘을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">stable_sort</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> cmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<h3>정렬 알고리즘 응용하기</h3>\n<p>정렬 알고리즘을 응용해서 문제를 푸는 방법</p>\n<h4><a href=\"https://www.acmicpc.net/problem/11652\">카드</a> (중요!)</h4>\n<ul>\n<li>문제: 여러 정수가 입력되었을 때, 가장 많이 가지고 있는 정수를 구하기 (가장 많이 가지고 있는 정수가 여러개일 경우, 그중 가장 작은 수 구하기)</li>\n<li>\n<p>풀이: 정렬된 리스트를 돌며 각 숫자의 연속된 개수를 세기</p>\n<ul>\n<li><strong>정렬하면 같은 수는 연속으로 나열</strong> 이 되기에 하나씩 iterate하며 각 숫자의 개수를 세면 됨</li>\n<li>개수를 세는 숫자를 저장해놓거나 이전 숫자와 비교하며,</li>\n<li>새로운 숫자가 나올 때까지 count를 세기</li>\n</ul>\n</li>\n<li><strong>tip</strong>: 따로 가장 작은 수를 체크할 필요없이, <strong>현재 max_count를 초과하는 개수의 숫자가 나타났을 때만 ans 값을 업데이트</strong> 하게 하면 됨</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/11004\">k번째 수</a> (중요!)</h4>\n<ul>\n<li>문제: 숫자를 정렬했을 때, k번째로 작은 수를 구하기</li>\n<li>\n<p>풀이: <strong>퀵정렬을 응용하여 partition된 배열의 개수를 통해 k번째 작은 수 찾기</strong></p>\n<ul>\n<li>pivot 값을 기준으로 <strong>나누어진 두 배열 각각의 개수를 통해 k번째 작은 수가 어느쪽에 속하는지 찾기</strong></li>\n<li>속하는 부분만 계속 퀵정렬 실행하며 k번째 수 찾고</li>\n<li>속하지 않는 부분은 퀵정렬할 필요 없이 그냥 냅둠</li>\n</ul>\n</li>\n</ul>\n<h4><a href=\"https://www.acmicpc.net/problem/1377\">버블 소트</a> (중요!)</h4>\n<ul>\n<li>문제: 주어진 숫자 배열들을 버블 소트했을 때, 총 몇 단계로 이루어지는지 세기</li>\n<li>\n<p>풀이: <strong>정렬 전과 후를 비교</strong> (뒤쪽에 있는 숫자가 앞쪽의 자리로 옮겨오는데 걸리는 단계 세기)</p>\n<ul>\n<li>큰 숫자가 뒤로 가는데는 한 패스씩밖에 걸리지 않지만,</li>\n<li>작은 숫자가 앞으로 가는데는 한 패스에 한 칸씩만 옮겨갈 수가 있음</li>\n<li>그러므로, 뒤에 있는 숫자가 앞으로 오는 가장 큰 칸 수를 구하면 됨</li>\n</ul>\n</li>\n<li>\n<p>주의: 만약 STL pair 자료구조를 사용하지 않고 임의로 custom 자료구조를 만들어서 사용한다면, </p>\n<ul>\n<li>비교 함수 오버로딩을 사용한다면, 한 필드가 같은 경우, 다른 필드까지 비교하게끔 정의</li>\n<li>STL 정렬 알고리즘을 사용한다면, 가능하면 <code class=\"language-text\">stable_sort</code>를 사용하여 필드가 같은 경우에는 이전의 순서를 유지할 수 있게끔 할 것</li>\n</ul>\n</li>\n</ul>","frontmatter":{"path":"/algorithm/baekjoon_basic/sort","title":"[백준] 기초 05. 정렬","date":"2019-04-21","tags":["백준","알고리즘","C++","정렬"]}}},"pageContext":{}}
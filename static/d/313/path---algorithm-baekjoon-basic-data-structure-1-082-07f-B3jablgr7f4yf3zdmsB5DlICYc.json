{"data":{"markdownRemark":{"html":"<h3>스택 (Stack)</h3>\n<ul>\n<li>Last-in-First-Out (LIFO)</li>\n<li>C++의 STL의 stack을 사용하여 push, pop, top, empty, size 연산을 사용.</li>\n<li>직접 구현할 경우, stack을 표현할 배열과 크기를 기록할 size 변수 사용.</li>\n<li>\n<p>가장 가까운 원소를 O(1)만에 찾을 수 있는 장점 (push &#x26; pop)을 적극적으로 활용해서 문제를 풀 것!</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">stack[size] = x; size++;     // push 연산\nstack[size - 1] = 0; size--; // pop 연산</code></pre></div>\n<ul>\n<li>괄호문제: empty check를 바탕으로 풀기 때문에 따로 스택을 만들 필요 없이, 그냥 size만 사용해도 풀 수 있다.</li>\n<li>에디터문제: 입력 크기를 고려하여 문자열 하나로 푸는 것이 아니라, 스택 두 개를 활용하여 풀어야 한다.</li>\n</ul>\n</li>\n</ul>\n<h3>큐 (Queue)</h3>\n<ul>\n<li>First-in-First-Out (FIFO)</li>\n<li>C++의 STL의 queue을 사용하여 push, pop, front, back, empty, size 연산을 사용.</li>\n<li>한 쪽에서 자료를 넣고 다른 쪽에서 자료를 뺄 수 있는 구조.</li>\n<li>back보다 front가 더 중요.</li>\n<li>양쪽에서 넣을 수 있다</li>\n<li>\n<p>직접 구현할 경우, queue을 표현할 배열과 시작 인덱스를 기록할 begin 변수와 마지막 인덱스를 기록할 end를 사용.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">queue[end] = x; end++;          // push 연산\nqueue[begin] = 0; begin += 1;   // pop 연산\nsize = end - begin;             // size 연산 \nempty = (begin == end)? 1 : 0;  // empty 연산</code></pre></div>\n<ul>\n<li>조세퍼스문제: 큐를 이용하여 풀기</li>\n</ul>\n</li>\n</ul>\n<h3>덱 (Deque)</h3>\n<ul>\n<li>double-ended queue: 양 끝에서 자료를 넣고 뺄 수 자료구조.</li>\n<li>C++의 STL의 queue을 사용하여 push<em>front, push</em>back, pop<em>front, pop</em>back, front, back 연산을 사용.</li>\n</ul>\n<h3>문자열 (String)</h3>\n<ul>\n<li>ASCII 코드를 사용하여 저장함.</li>\n<li>\n<p>단어 길이가 필요 시, 아래와 같이 len값을 따로 저장하여 사용해야 O(n) 실행 가능 (매번 루프에서 조건체크 시 strlen 호출하면 O(n^2)가 걸린다)</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">int len = strlen(s);\nfor (int i = 0; i &lt; len; i ++)</code></pre></div>\n</li>\n<li>문자열 -> 정수 변환: stoi(), stol(), stoll() 사용</li>\n<li>정수 -> 문자열 변한: to_string()</li>\n</ul>","frontmatter":{"path":"/algorithm/baekjoon_basic/data_structure_1","title":"[백준] 강의노트 02. 자료구조 1","date":"2018-01-25","tags":["백준","알고리즘","C++","강의노트","자료구조"]}}},"pageContext":{}}
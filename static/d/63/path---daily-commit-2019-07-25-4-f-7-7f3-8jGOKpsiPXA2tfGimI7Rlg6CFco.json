{"data":{"markdownRemark":{"html":"<h3>오늘의 커밋</h3>\n<h4>freecodecamp 팟캐스트 interview w/ david mallan and colton</h4>\n<h4>Hackerrank 문제 풀기</h4>\n<blockquote>\n<p>요즘 하루에 적어도 문제 한 개는 풀려고 노력하고 있다. 오늘은 예전에 풀다가 막혀서 못 풀은 'Tree: top view' 문제를 풀었다. 그리고 오늘도 여지없이, 문제를 풀다가 당황했다 (이제 순간 당황은 트리 문제에 달려오는 플러스 원 같은 존재가 되었다). 트리의 각 노드를 순회하기 위해 노드 순서를 기록하는데 큐와 스택 어느 것을 사용하면 좋을지에서 1차 당황하고, 이를 알아내기 위해 DFS와 BFS를 고민하는데 잘 기억이 나지 않아 2차 당황했다. 조금 헤매긴 했지만, 결국 큐를 사용하여 BFS로 트리 순회를 하여 문제를 풀었다. BFS와 DFS 부분을 다시 복습해야겠다는 생각이 들었다. 그래도 나름 문제를 최적화시키는 것까지 스스로 생각해서 풀어서 뿌듯했다. 처음에 Top view 백터의 양쪽에 노드를 계속 추가해나가는 방식을 생각했었는데, 만약 앞에 새로 노드를 추가하면 STL을 사용하더라도 실제로는 각 노드 추가 시 O(n)이 걸리기 때문에 O(n^2) 시간 복잡도여서 이 부분을 최적화해보았다. 앞 뒤로 백터에 새 값들을 추가하기보다는, 왼쪽 백터와 오른쪽 백터를 분리하여 각각 추가하고, 마지막에는 왼쪽 백터를 뒤집는 방법으로 저 문제를 해결하여 최종적으로 O(n)의 시간과 O(n) 공간복잡도를 가지는 해답을 제출했다.</p>\n</blockquote>\n<h3>오늘의 풀리퀘스트</h3>\n<ul>\n<li>트리 순회: BFS와 DFS 복습하기!</li>\n</ul>","frontmatter":{"title":"[일일커밋] 9만큼 커밋해!","date":"2019-07-25","tags":["일일커밋"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Daily_Commit/2019_07_25/"}}
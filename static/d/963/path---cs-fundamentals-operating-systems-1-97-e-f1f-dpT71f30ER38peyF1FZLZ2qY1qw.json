{"data":{"markdownRemark":{"html":"<blockquote>\n</blockquote>\n<h3>프로그램 실행 과정</h3>\n<ol>\n<li>\n<p>메모리 로드 (load): 디스크의 파일 시스템에 있는 프로그램 A 파일 -> 메모리 영역(ram)으로 올리기</p>\n<ul>\n<li>프로그램 A의 가상메모리 주소 공간(stack, data, code) 만들어서, 당장 필요한 부분만 메모리에 올리고 (메모리에 올라간 코드 = 프로세스), 나머지는 디스크의 스왑(swap) 영역으로 넣음</li>\n<li>필요에 따라 디스크의 스왑에서 정보를 올렸다 내렸다 함</li>\n</ul>\n</li>\n<li>사용자 모드(user mode)로 모드비트(mode bit)를 설정해두고 자기 코드 실행</li>\n<li>\n<p>만일 코드 실행 중 I/O 작업이 필요한 경우,</p>\n<ol>\n<li>\n<p>trap(소프트웨어 인터럽트의 한 종류)을 사용: </p>\n<ol>\n<li>현 시점의 register와 program count(pc)를 저장하고</li>\n<li>커널 모드(kernel mode, monitor mode, system mode)로 변경한 후 </li>\n<li>\n<p>시스템 콜: 해당 인터럽트의 종류에 해당하는 커널 함수 호출 </p>\n<ul>\n<li>좀 더 구체적으로, 커널 인터럽트 벡터에서 해당 인터럽트에 매칭되는 인터럽트 처리 루틴/인터럽트 핸들러; interrupt service routine 주소를 찾아 해당 함수를 호출하는 것</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>해당 i/o 작업 수행</p>\n<ul>\n<li>i/o 작업 종류에 따라 동기식, 비동기식 i/o가 진행됨</li>\n<li>ex. read 작업 -> 동기식이어야 함 so 프로세스 A 진행은 현재 코드에서 실행이 멈춰있는 상태 (다른 프로세스는 실행이 가능하다; i/o작업은 디바이스 컨트롤러에 맡기고 cpu는 계속 기다리거나, 다른 프로세스 B를 실행할 수도 있음)</li>\n<li>ex. write, thread 작업 -> 비동기식 가능 so 프로세스 A의 i/o 작업과 동시에 그 후의 코드도 실행이 가능 (i/o작업은  디바이스 컨트롤러에 맡기고 cpu는 그 후의 코드를 진행)</li>\n</ul>\n</li>\n<li>i/o 완료 시</li>\n</ol>\n</li>\n</ol>\n<h3>입출력 실행 과정</h3>","frontmatter":{"title":"[OS] 1. 프로그램 실행","date":"2019-08-18","tags":["운영체제"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/CS_Fundamentals/Operating_Systems/1/"}}
{"data":{"markdownRemark":{"html":"<blockquote>\n<p>Understanding JavaScript</p>\n</blockquote>\n<h3>JavaScript</h3>\n<ul>\n<li><em>interpreted language</em>: read and execute line by line</li>\n<li>each browser has their own JavaScript engine that interprets the code</li>\n<li><strong>ECMAScript standard</strong></li>\n</ul>\n<h3>Types</h3>\n<p>JavaScript has <strong>dynamic typing</strong></p>\n<ul>\n<li>variables are not associated w/ specific types</li>\n<li>\n<p><strong>primitive types</strong>: <em>no methods, immutable</em></p>\n<ul>\n<li><code>undefined</code>: <em>falsy</em> value</li>\n<li><code>null</code>: <em>falsy</em> value</li>\n<li><code>boolean</code>: false = <em>falsy</em> value</li>\n<li><code>number</code>: 0 = <em>falsy</em> value</li>\n<li><code>string</code></li>\n<li><code>symbol</code></li>\n</ul>\n</li>\n<li><strong>objects</strong>: every other type is object</li>\n</ul>\n<h4>Typecasting</h4>\n<p>changing one type to another type (a.k.a <strong>coercion</strong>)</p>\n<ul>\n<li>\n<p><em>explicit coercion</em>: being explicit in changing types</p>\n<ul>\n<li>ex. const string_x = String(x);</li>\n</ul>\n</li>\n<li>\n<p><em>implicit coercion</em></p>\n<ul>\n<li>ex. const string_x = x + \" \";</li>\n</ul>\n</li>\n</ul>\n<h4>Check Types</h4>\n<ul>\n<li><strong>check type</strong>: <code>typeof</code></li>\n<li>\n<p><strong>compare values</strong></p>\n<ul>\n<li>\n<p><code>==</code>: coerce the types (types don't have to be equivalent)</p>\n<ul>\n<li><strong>never use!</strong> (bcuz) you have to know all the coerce types to use it</li>\n</ul>\n</li>\n<li><code>===</code>: requires equivalent types</li>\n</ul>\n</li>\n</ul>\n<h3>Objects</h3>\n<p>everything else than the primitive types</p>\n<ul>\n<li>include <strong>objects, arrays, and functions</strong></li>\n<li>mutable and stored by reference</li>\n<li>\n<p><em>three ways</em> to <strong>create objects</strong>:</p>\n<pre><code class=\"language-js\">const d = new Object();\nd.name = \"dragon\"\nd.isAlive = true\no.fire = function () {\nconsole.log('fire!')\n}\n</code></pre>\n<pre><code class=\"language-js\">const d = {}\nd.name = 'dragon'\nd{'isAlive'} = true\n</code></pre>\n<pre><code class=\"language-js\">const d = {\nname: \"dragon\",\nisAlive: true,\nfire: function {\n    console.log('fire!')\n},\n}\n</code></pre>\n</li>\n<li><strong>access</strong>: by <code>.key</code> or <code>['key']</code></li>\n</ul>\n<h4>Object Mutation</h4>\n<ul>\n<li>objects are <strong>passed by reference</strong></li>\n<li>acts like pointers</li>\n<li>assigning <code>=</code>: <em>pointing to the reference</em></li>\n<li>\n<p>copying <code>Object.assign({}, _copy_)</code>: create new object and merge the values</p>\n<pre><code class=\"language-js\">// o1 and o2 point to the same object\nconst o1 = {\n    a: 'a',\n}\nconst o2 = o1 \n// o3 points to a completely different object\n// but same values bcuz merged o1's values into o3\nconst o3 = Object.assign({}, o1)\n</code></pre>\n</li>\n</ul>\n<h4>Prototypal Inheritance</h4>\n<ul>\n<li>\n<p>primitive types do not have methods associated w/ them</p>\n<ul>\n<li>but can use <strong>wrappers</strong> which give access to methods</li>\n<li>primitive types are <em>automatically wrapped/boxed</em> when used as variable</li>\n</ul>\n</li>\n<li>\n<p><strong>non-primitive types (objects)</strong> have <strong>properties</strong> and <strong>methods</strong></p>\n<ul>\n<li>each object stores a <strong>reference to its prototype</strong></li>\n<li>the more specific prototype, its methods</li>\n</ul>\n</li>\n<li>it is __dangerous to make changes to prototypes</li>\n</ul>\n<h3>Scope</h3>\n<p>variable lifetime (how long a variable exists)</p>\n<ul>\n<li>lexical scoping: <code>var</code></li>\n<li>block scoping: <code>const</code> and <code>let</code></li>\n<li>global scoping: declared w/o scoping</li>\n</ul>\n<h4>How JavaScript Engine Works</h4>\n<ul>\n<li>\n<p>before executing the code, the <strong>engine read the entire file first</strong> and will <em>throw a syntax error if one is found</em></p>\n<ul>\n<li><em>any function definition will be saved in memory</em></li>\n<li>variable initializations will not be run, but <em>lexically-scoped variable (var) names will be declared</em></li>\n</ul>\n</li>\n<li>\n<p>then, <strong>code is executed</strong></p>\n<ul>\n<li><em>block-scoped variables (let, const) names will be declared</em></li>\n</ul>\n</li>\n</ul>\n<h4>Hoisting</h4>\n<ul>\n<li><strong>variables and function declarations</strong> are <strong>moved to the top</strong> of their scope <strong>before code execution</strong></li>\n</ul>\n<h3>Global Object</h3>\n<ul>\n<li>\n<p><strong>all variables and functions</strong>: <em>parameters and methods on the global object</em></p>\n<ul>\n<li><em>Browser global object</em> = <strong>window object</strong></li>\n<li><em>Node.js global object</em> = <strong>global object</strong></li>\n</ul>\n</li>\n</ul>","frontmatter":{"path":"/mobile50/0","title":"Mobile50 lecture 0 - JavaScript","date":"2019-03-15","tags":["웹개발","프론트엔드","JavaScript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}
{"data":{"markdownRemark":{"html":"<blockquote>\n<p>Harvard's Web Programming with Python and Javascript lecture 5 정리</p>\n</blockquote>\n<h3>JavaScript</h3>\n<p>programming language designed to run inside a browser that runs on <strong>client-side</strong></p>\n<ul>\n<li>client-side processes reduce load on the server and are often faster</li>\n</ul>\n<h4>Syntax</h4>\n<ul>\n<li><strong>Variables</strong>: <code>const</code>, <code>let</code> (local to scope), <code>var</code> (local to function)</li>\n<li><strong>Literals</strong>: <code>Hello, ${name}</code></li>\n<li>\n<p><strong>Selectors</strong>: </p>\n<ul>\n<li><code>document.querySelector(\" \")</code></li>\n<li><code>document.querySelectorAll(\" \")</code></li>\n<li>can change styles: <code>__.style._property_</code></li>\n<li>\n<p>can change classes: </p>\n<ul>\n<li><code>__.ClassName</code></li>\n<li><code>__ClassList.add</code>, <code>__ClassList.remove</code>, <code>__ClassList.toggle</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Event Listeners</strong>: <code>__.addEventListener(_event_, function() { ... });</code></p>\n<ul>\n<li>listens/waits for the event to occur</li>\n<li>when event occured, the function is called (<strong>call back functions</strong>)</li>\n</ul>\n</li>\n<li>\n<p><strong>Arrow Functions</strong>: <code>() => {}</code></p>\n<ul>\n<li>\n<p>used to define <strong>anonymous functions</strong> (w/o the word <em>function</em>)</p>\n<pre><code class=\"language-js\">x => x + 2;\n</code></pre>\n<pre><code class=\"language-js\">x => { alert(x); }\n</code></pre>\n<pre><code class=\"language-js\">() => { alert(Hello); }\n</code></pre>\n<pre><code class=\"language-js\">document.addEventListener('DOMContentLoaded', () => {\n    document.querySelector(\"h1\").style.color = 'red';\n});\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4>JavaScript Examples</h4>\n<ul>\n<li>\n<p>To Do List</p>\n<pre><code class=\"language-js\">document.addEventListener('DOMContentLoaded', () => {\n    // when form is submitted, \n    document.querySelector('#new-task').onsubmit = () => {\n        // create a list item element\n        const li = document.createElement('li');\n        // assign the input value into the content of the list item\n        li.textContent = document.querySelector('#task').value;\n        // append the list item to list\n        document.querySelector('#tasks').append(li)';\n        // reset the input value in form to blank\n        document.querySelector('#task').value = '';\n        // stop from from submitting\n        return false;\n    }\n});\n</code></pre>\n</li>\n<li>\n<p>Timer (increment count by 1s)</p>\n<pre><code class=\"language-js\">document.addEventListener('DOMContentLoaded', () => {\n    setInterval(count, 1000);\n});\nlet counter = 0;\nfunction count() {\n    counter++;\n    document.querySelector('#counter').textContent = counter;\n}\n// problem: counter resets everytime the browser reloads\n</code></pre>\n</li>\n<li>\n<p>Timer (w/ local storage)</p>\n<pre><code class=\"language-js\">// if no counter, set as 0\nif (!localStorage.getItem('counter')) {\n    localStorage.setItem('counter', 0);\n}\ndocument.addEventListener('DOMContentLoaded', () => {\n    // set the counter content as counted before\n    document.querySelector('#counter').textContent = localStorage.getItem('counter');\n    // when button is clicked,\n    document.querySelector('button').onclick = () => {\n        // increment count\n        let counter = localStorage.getItem('counter');\n        coutner++;\n        // update counter content value\n        document.querySelector(\"#counter').textContent = counter;\n        // store updated value in local storage\n        localStorage.setItem('counter', counter);\n    }\n});\n</code></pre>\n</li>\n</ul>\n<h3>Network Models</h3>\n<ul>\n<li>\n<p><strong>Request-Response model</strong></p>\n<ul>\n<li>basis of HTTP requests and how client-server model works</li>\n<li>useful as long as <strong>data is only being passed when a request is made</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>Ajax</strong></p>\n<ul>\n<li>also <strong>based on request-response model</strong></li>\n<li>can make a request to access server-side resource <strong>while not holding up the app to wait for response</strong></li>\n<li>uses <strong>callback functions</strong> to be invoked when response is ready</li>\n</ul>\n</li>\n<li>\n<p><strong>Web Sockets</strong></p>\n<ul>\n<li><strong>based on event model</strong></li>\n<li><strong>persistent connection</strong></li>\n<li>\n<p>useful for <strong>when data is transferred frequently</strong></p>\n<ul>\n<li>data 양이 많아 매번 request를 일일이 매번 만드는 것이 inefficient하기에 web socket가 더 유용</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Ajax (Asynchronous JavaScript and XML)</h3>\n<p>asynchronous way of getting data from server</p>\n<ul>\n<li>used to <strong>get more information from server w/o reloading</strong> an entirely new page</li>\n<li>used on the client-side to create asynchronous web apps</li>\n<li><em>굳이 client-side, server-side 따지지 말기</em> (<strong>ajax is its own concept</strong>; bridge btw server &#x26; client)</li>\n</ul>\n<h4>Making an Ajax Call</h4>\n<ol>\n<li>\n<p>make a <strong>request</strong>: <code>const request = new XMLHttpRequest()</code></p>\n</li>\n<li>\n<p>set the <strong>method</strong> &#x26; <strong>route</strong>: <code>request.open('GET', '/')</code> or <code>request.open('POST', '/')</code></p>\n</li>\n<li>\n<p>define the <strong>callback function</strong>: <code>request.onload = () => { ... }</code></p>\n<ul>\n<li>use w/ <code>const data = JSON.parse(request.responseText)</code> to <em>parse response data</em></li>\n<li>check <strong>data success</strong> and fail cases</li>\n</ul>\n</li>\n<li>\n<p><strong>send request</strong>: <code>request.send()</code> or <code>request.send(data)</code></p>\n<ul>\n<li>\n<p>if post request, use w/ <code>const data = new FormData()</code> and <em>append object to it</em></p>\n<pre><code class=\"language-js\">document.addEventListener('DOMContentLoaded', () => {\n    document.querySelector('#form').onsubmit = () => {\n        // create a request\n        const request = new XMLHttpRequest();\n        const currency = document.querySelector('#currency').value;\n\n        // set the method and route of the request\n        request.open('POST', '/convert');\n\n        // callback function when request is completed\n        request.onload = () => {\n            const data = JSON.parse(request.responseText);\n            // if successfully received resonse, show content currency\n            if (data.success) {\n                const content = `1 usd = $ {data.rate} $ {currency}`;\n                document.querySelector('#results').textContent = content;\n            }\n            // else print error\n            else {\n                document.querySelector('#results').textContent = 'error';\n            }\n        };\n        // create an object to hold the user input in\n        const data = new FormData();\n        data.append('currency', currency);\n\n        // send data\n        request.send(data);\n        return false;\n    };\n});\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3>Web Sockets</h3>\n<p>protocol that allows <strong>full duplex communication</strong></p>\n<ul>\n<li>allows to open and persist a connection to server so data is transferred quickly</li>\n<li>enables <strong>real-time communication</strong></li>\n<li><strong>both client &#x26; server can send messages</strong></li>\n</ul>\n<h4>Using Web Sockets</h4>\n<ul>\n<li>add a specific reference script to the html</li>\n<li>\n<p>use socket in custom script (js)</p>\n<ul>\n<li><code>var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port)</code></li>\n<li><code>socket.on('connect', () => { ... }</code></li>\n<li><code>socket.emit('submit vote', {'selection': selection})</code></li>\n<li>\n<p><code>socket.on('announce vote', data => { ... }</code></p>\n<pre><code class=\"language-js\">document.addEventListener('DOMContentLoaded', () => {\n    // create a socket connection\n    var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port);\n    socket.on('connect', () => {\n        // if button is clicked, emit a message to server\n        document.querySelectorAll('button').forEach(button => {\n            button.onclick = () => {\n                const selection = button.dataset.vote;\n                socket.emit('submit vote', {'selection': selection});\n            };\n        });\n    });\n    // when a message is received from server, display vote\n    socket.on('announce vote', data => {\n        const li = document.createElement('li');\n        li.textContent = `vote recorded: ${data.selection}`;\n        document.querySelector('#votes').append(li);\n    })\n});\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>enable sockets in server</p>\n<pre><code class=\"language-python\"># Enable sockets in Flask server\nimport os\nimport requests\nfrom flask import Flask, jsonify, render_template, \nfrom flask_socketio import SocketIO, emit\napp = Flask(__name__)\n# create socket\nsocketio = SocketIO(app)\n# when server receives message, emit message to all (broadcast)\n@socketio.on(\"submit vote\")\ndef vote(data):\n    selection = data['selection']\n    emit(\"announce vote\", {\"selection\": selection}, broadcast=True)\n</code></pre>\n</li>\n</ul>","frontmatter":{"path":"/web50/5","title":"Web50 lecture 5 - JavaScript & Web Sockets","date":"2018-08-21","tags":["CS50","Web50","JavaScript","웹소켓"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}
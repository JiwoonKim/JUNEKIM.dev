{"data":{"markdownRemark":{"html":"<h3>정렬</h3>\n<p><strong>어떤 자료를 순서대로 배열하는 것</strong></p>\n<ul>\n<li>\n<p>다양한 방식이 존재: 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 힙 정렬, 병합 정렬, etc.</p>\n<ul>\n<li>O(n^2)과 O(nlogn)으로 크게 나누어진다.</li>\n</ul>\n</li>\n<li>빠를수록 좋기에 <strong>O(nlogn)인 퀵 정렬, 힙 정렬, 병합 정렬을 주로 사용</strong> 한다.</li>\n<li>\n<p><strong>직접 구현하기보다는 STL에 있는 <code class=\"language-text\">sort</code> 함수를 사용</strong> 하는 것이 좋다.</p>\n<ul>\n<li><code class=\"language-text\">sort(begin, end)</code>: begin부터 end 바로 전까지를 정렬</li>\n</ul>\n</li>\n</ul>\n<h4>퀵 정렬 (Quick Sort) 구현</h4>\n<ul>\n<li><strong>O(N*logN)</strong> 의 시간복잡도를 가지는 <strong>분할정복 알고리즘</strong> 이다.</li>\n<li>\n<p><strong>기준 값을 중심으로 계속 배열을 나누어나가는 방법</strong> 이다.</p>\n<ul>\n<li>기준 값을 중심으로 나누기 때문에 합치는 부분은 필요 X</li>\n</ul>\n</li>\n<li>\n<p>크게 두 부분으로 나누어 구현:</p>\n<ol>\n<li>\n<p><strong>Partition</strong>: pivot을 기준으로 <strong>두 부분으로 나누기</strong></p>\n<ul>\n<li>pivot 값을 정한 후, <strong>배열의 끝으로 위치</strong> 시킴으로써 그 전값들과 값 비교가 용이하게 하기</li>\n<li>모든 값 비교 후, pivot보다 <strong>작은 값들 다음 인덱스로 다시 pivot 값 위치시키기</strong></li>\n<li>왼쪽은 pivot보다 작은 값들, 오른쪽은 더 큰 값들의 결과가 나온다 (<strong>단, 각각 부분이 정렬된 상태 X</strong>)</li>\n</ul>\n</li>\n<li>\n<p><strong>Quicksort Recursion</strong>: 나누어진 두 부분을 각각 다시 partition한 후 quicksort</p>\n<ul>\n<li>배열의 원소가 하나일 때까지 partition하여 quicksort 실행</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>swap 함수를 별도로 정의하여 사용하면 편리</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> lowIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> highIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">// 값이 두 개 이상인 배열만 partition하여 quicksort 실행</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>highIndex <span class=\"token operator\">></span> lowIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// partition하기</span>\n    <span class=\"token keyword\">int</span> pivotIndex <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>lowIndex<span class=\"token punctuation\">,</span> highIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 나누어진 두 부분에 대해 각각 quicksort 다시 실행</span>\n    <span class=\"token comment\">// pivot 값은 그대로 냅두고 이를 제외한 두 부분을 정렬 (재귀)</span>\n    <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>lowIndex<span class=\"token punctuation\">,</span> pivotIndex <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>pivotIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> highIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> lowIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> highIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">// Pivot을 정하여 그 값을 배열 끝자리(highIndex)로 옮기기</span>\n<span class=\"token comment\">// 그래야 lowIndex ~ highIndex 전까지의 값들과 pivot 값 비교가 쉬움</span>\n<span class=\"token keyword\">int</span> pivotIndex <span class=\"token operator\">=</span> low <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>highIndex <span class=\"token operator\">-</span> lowIndex<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>pivotIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>highIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 다른 값들과 pivot값 (@highIndex) 비교함으로써 배열을 둘로 나누기</span>\n<span class=\"token keyword\">int</span> leftEndIndex <span class=\"token operator\">=</span> lowIndex<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> lowIndex<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> highIndex<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>highIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>leftEndIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        leftEndIndex <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 마지막으로 왼쪽 배열 다음 값으로 pivot 값 옮기기</span>\n<span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>highIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>leftEndIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// pivot 값이 위치한 인덱스 반환</span>\n<span class=\"token keyword\">return</span> leftEndIndex<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">/* 직접적으로 함수에 배열을 전달하는 방법은 함수 호출할 때마다 \n배열의 형태를 고려해야하는 번거로움이 있기 때문에 swap이 편리함 */</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\na <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\nb <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h4>병합 정렬 (Merge Sort) 구현</h4>\n<ul>\n<li><strong>O(N*logN)</strong> 의 시간복잡도를 가지는 <strong>분할정복 알고리즘</strong> 이다.</li>\n<li><strong>배열을 무조건 반으로 계속 나눈 후 합치면서 정렬해나가는 방법</strong> 이다.</li>\n<li>\n<p>크게 두 부분으로 나누어 구현:</p>\n<ol>\n<li><strong>Divide</strong>:  원소가 하나 남은 상태일 때까지 <strong>계속 배열을 반으로 나누기</strong></li>\n<li>\n<p><strong>Merge</strong>: 나누어진 두 배열의 원소들을 <strong>차례대로 비교하면서 하나의 배열로 합치기</strong>; <strong>합치는 과정에서 정렬</strong></p>\n<ul>\n<li>두 배열을 합치는 과정에서만 원소 간 비교가 필요하며, 합친 결과는 임시 배열에 저장</li>\n<li>비교 후 한 쪽 배열에 원소가 남아있다면, 그대로 원소들을 차례대로 옮기기</li>\n<li>마지막으로 임시적으로 합친 배열을 <strong>다시 원래 배열으로 옮겨 저장</strong></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>값들을 합치는 과정을 일시적으로 저장할 temporary 배열을 사용하기</strong> </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// a 배열에 있는 값들을 나누어나가고 </span>\n<span class=\"token comment\">// 합치면서 정렬한 결과를 b 배열에 저장</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> merged<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">//  원소가 하나일 경우, 그대로 냅두기</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">==</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 원소가 하나만 있을 때까지, 배열을 반으로 나누기</span>\n<span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 두 배열을 합치기 (이 과정에서 정렬이 됨)</span>\n<span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">// 배열 merged의 인덱스를 track해 나갈 변수 정의</span>\n<span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 나누어진 두 배열 각각의 시작점부터 차례대로 원소들 비교해나가기</span>\n<span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> leftTurn <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> rightTurn <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>leftTurn <span class=\"token operator\">&lt;=</span> mid <span class=\"token operator\">&amp;&amp;</span> rightTurn <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 비교 결과 더 작은 값을 merged 배열에 저장</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>leftTurn<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> a<span class=\"token punctuation\">[</span>rightTurn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        merged<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>leftTurn<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        merged<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>rightTurn<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 비교하는 두 배열 중 merged로 옮겨지지 않은 원소가 있을 경우, 차례대로 옮기기 </span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>leftTurn <span class=\"token operator\">&lt;=</span> mid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    merged<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>leftTurn<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>rightTurn <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    merged<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>rightTurn<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 마지막으로, merged 된 배열의 값들을 다시 a 배열로 옮긴다 (overwrite)</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> merged<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h4>퀵 정렬과 병합 정렬 비교</h4>\n<ul>\n<li><strong>공통점</strong>: <strong>O(N * logN)의 시간복잡도</strong>, <strong>분할정복 알고리즘</strong> 에 기반한다.</li>\n<li>\n<p><strong>차이점</strong>:</p>\n<ul>\n<li>퀵 정렬: 기준값을 가지고 배열을 나누어나가기 때문에, <strong>나누어나가는 과정에서 정렬</strong> 이 된다. (따로 병합 과정이 필요 X; 있는 그대로 이어붙이면 정렬된 상태)</li>\n<li>병합 정렬: 무조건 반으로 배열을 나누어나가기 때문에, 나누어진 두 배열의 값들을 하나하나 비교하면서 정렬해야 한다. 결국, <strong>병합하는 과정에서 정렬</strong> 이 된다.</li>\n</ul>\n</li>\n</ul>\n<h3>특별한 조건으로 정렬</h3>\n<h4>특수한 자료를 정렬해야 할 때</h4>\n<p>기본자료형 (정수, 문자열, etc.)가 아닌 자료를 정렬해야 할 때</p>\n<ol>\n<li>STL 자료형을 변형하여 사용 가능</li>\n<li>\n<p><strong>구조체(struct)로 정의하여 사용</strong> (cmp 함수를 연산자 오버로딩을 할 수도 있음)</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> Point <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 연산자 오버로딩하여 구현</span>\n<span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span> <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Point <span class=\"token operator\">&amp;</span>v<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> x <span class=\"token operator\">&lt;</span> v<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ol>\n<h4>특별한 조건을 기반으로 정렬해야 할 때:</h4>\n<ul>\n<li>\n<p><strong>cmp 함수</strong> 를 조건에 맞춰 따로 정의한 후 <code class=\"language-text\">sort(start, end, cmp)</code>을 사용</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> cmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">cmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">return</span> u <span class=\"token operator\">&lt;</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// u &lt; v가 true인 경우, u가 v보다 앞에 옴</span>\n<span class=\"token comment\">// false인 경우 (u > v), u가 v보다 뒤에 옴</span></code></pre></div>\n</li>\n</ul>\n<h3>안전 정렬 (Stable Sorting)</h3>\n<ul>\n<li><strong>같은 것이 있는 경우에 정렬하기 전의 순서가 유지되는 정렬 알고리즘</strong></li>\n<li>병합정렬 (merge sort)가 정렬 알고리즘에 해당</li>\n<li>STL에는 <code class=\"language-text\">stable_sort</code> 알고리즘을 사용</li>\n</ul>","frontmatter":{"path":"/algorithm/baekjoon_basic/sort","title":"[백준] 강의노트 05. 정렬","date":"2019-04-21","tags":["백준","알고리즘","C++","강의노트","정렬"]}}},"pageContext":{}}
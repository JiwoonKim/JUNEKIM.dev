{"data":{"markdownRemark":{"html":"<blockquote>\n<p>Standard Template Library (STL)는 알고리즘, 컨테이너, 함수, 이터레이터로 이루어져 있으며 그 중 알고리즘을 정리.</p>\n</blockquote>\n<h3>알고리즘 (Algorithm)</h3>\n<ul>\n<li><a href=\"#count\">Count</a>, <a href=\"#find\">Find</a>, <a href=\"#fill\">Fill</a>, <a href=\"#reverse\">Reverse</a>, <a href=\"#rotate\">Rotate</a>, <a href=\"sSwap\">Swap</a>, <a href=\"#unique\">Unique</a>, <a href=\"#sort\">Sort</a>, <a href=\"#stable_sort\">Stable_sort</a>, <a href=\"#binary_search\">Binary_search</a>, <a href=\"#lower_bound___upper_bound\">Lower<em>bound, Upper</em>bound</a>, <a href=\"#min___max\">Min, Max</a>, <a href=\"#min_element___max_element\">Min<em>element, Max</em>element</a>, <a href=\"#next_permutation\">Next_permutation</a></li>\n</ul>\n<h4>Count</h4>\n<ul>\n<li><code>count(begin, end, value)</code>: [begin, end)에 포함되어 있는 원소 중에서 value의 개수를 찾는다.</li>\n<li><code>count_if(begin, end, p)</code>: [begin, end)에 포함되어 있는 원소 중에서 조건 p에 해당하는 것에 개수를 찾는다.</li>\n<li>\n<p>시간복잡도: O(N)</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {1, 2, 2, 3, 4, 5};\nfor (int i = 1; i &#x3C;= 5; i++) { \n    cout &#x3C;&#x3C; i &#x3C;&#x3C; \"의 개수: \" &#x3C;&#x3C; count(v.begin(), b.end(), i);\n}\nint even = count_if(v.begin(), b.end(), [](int x) {\n    return x % 2 == 0;\n});\ncout &#x3C;&#x3C; \"짝수의 개수: \" &#x3C;&#x3C; even;\n</code></pre>\n</li>\n</ul>\n<h4>Find</h4>\n<ul>\n<li><code>find(begin, end, value)</code>: [begin, end)에 포함되어 있는 원소 중에서 첫번째 value의 이터레이터를 반환한다.</li>\n<li><code>find_if(begin, end, value)</code>: [begin, end)에 포함되어 있는 원소 중에서 조건 p에 해당하는 것의 첫번째 이터레이터를 반환한다.</li>\n<li>찾는 것이 없는 경우에는 end를 반환한다.</li>\n<li>\n<p>시간복잡도: O(N)</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\n// find 함수 예시\nvector&#x3C;int> v = {1, 2, 2, 3, 4, 5};\nauto it = find(v.begin(), v.end(), 2);\nif (auto == v.end()) {\n    cout &#x3C;&#x3C; \"찾을 수 없음\\n\"; // end()값과 같으면 벡터에 원소가 없음\n}\nelse {\n    cout &#x3C;&#x3C; (it - v.begin()); // 인덱스는 begin()값을 빼야지 계산 가능\n}\n// find_if 함수 예시 ()\nauto even = find_if(v.begin(), v.end() [](int x ) {\n    return x % 2 == 0;\n});\ncout &#x3C;&#x3C; \"첫 번째 짝수: \" &#x3C;&#x3C; (even - v.begin()) &#x3C;&#x3C; \"\\n\";\n</code></pre>\n</li>\n</ul>\n<h4>Fill</h4>\n<ul>\n<li><code>fill(begin, end, value)</code>: [begin, end)를 value의 값으로 채운다.</li>\n<li>\n<p>시간복잡도: O(N)</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {1, 2, 3, 4, 5};\nfill(v.begin(), v.end(), 0); // {0, 0, 0, 0, 0}으로 설정\n</code></pre>\n</li>\n</ul>\n<h4>Reverse</h4>\n<ul>\n<li><code>reverse(begin, end)</code>: [begin, end)의 순서를 역순으로 만든다.</li>\n<li>\n<p>시간복잡도: O(N)</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {1, 2, 3, 4, 5};\nreverse(v.begin(), v.end()); // {5, 4, 3, 2, 1}으로 바뀜\n</code></pre>\n</li>\n</ul>\n<h4>Rotate</h4>\n<ul>\n<li><code>rotate(begin, mid, end)</code>: [begin, end)를 mid를 기준으로 왼쪽으로 회전시킨다 (a.k.a shift: <em>mid 값이 begin에 들어가고</em>, 순서대로 end-1 값까지 들어간다)</li>\n<li>\n<p>시간복잡도: O(N)</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {1, 2, 3, 4, 5};\nint n = v.size();\nfor (int i = 0; i &#x3C; n; i++) {\n    // 차례대로 {2, 3, 4, 5, 1}부터 다시 {1, 2, 3, 4, 5}까지 회전\n    rotate(v.begin(), v.begin()+1, v.end());\n}\n</code></pre>\n</li>\n</ul>\n<h4>Swap</h4>\n<ul>\n<li>\n<p><code>swap(a, b)</code>: a와 b에 들어있던 값을 바꾼다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;algorithm>\nint a = 10;\nint b = 20;\nswap(a, b); // a = 20, b = 10으로 바뀜\n</code></pre>\n</li>\n</ul>\n<h4>Unique</h4>\n<ul>\n<li><code>unique(begin, end)</code>: [begin, end) 구간에서 연속되는 중복 값들은 하나만 남기고 삭제한다.</li>\n<li>\n<p>좌표압축(범위 내에서 값들이 중구난방일 때 1부터 n까지 정렬할 때) 유용하게 쓰인다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {1, 1, 1, 2, 3, 1, 1, 2};\nauto last = unique(v.begin(), v.end()); // {1, 2, 3, 1, 2, 1, 1, 2}\ncout &#x3C;&#x3C; last; // last는 {1, 2, 3, 1, 2} 다음의 이터레이터 반환\n</code></pre>\n</li>\n<li>실제로는 연속된 값들이 삭제되는 것이 아니라 중복된 값들을 덮어씌우거나 시프트하는 방식으로 값들을 하나씩만 정렬하고 나머지는 뒤에 그대로 갖다 붙이기 때문에 <strong>사용 후 erase를 통해 뒤에 값들을 삭제하는 추가적인 과정을 거쳐야 한다</strong>.</li>\n<li>범위에서 각 값들을 하나씩만 남기고 싶다면 <strong>정렬된 상태로 사용</strong> 하는 것이 좋다. </li>\n<li>\n<p>이 때, unique의 return 값 (= 중복이 끝나는 부분의 이터레이터)를 사용한다.</p>\n<pre><code class=\"language-cpp\">// 중복이 끝나는 시점부터 끝까지 삭제\nv.erase(last, v.end()); // {1, 2, 3, 1, 2}만 남는다\n</code></pre>\n</li>\n</ul>\n<h4>Sort</h4>\n<ul>\n<li>\n<p><code>sort(begin, end)</code>: [begin, end)를 <strong>오름차순</strong>('&#x3C;' 기준)으로 정렬한다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\n// default 오름차순으로 정렬하기\nvector&#x3C;int> v = { 5, 3, 2, 1, 4};\nsort(v.begin(), v.end()); // {1, 2, 3, 4, 5}의 오름차순으로 정렬됨\n</code></pre>\n</li>\n<li>\n<p><code>sort(begin, end, cmp)</code>: [begin, end)를 <strong>cmp</strong> 비교함수를 만들어 그 기준으로 정렬한다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = { 5, 3, 2, 1, 4};\n// 내림차순으로 정렬하는 다양한 방법: {5, 4, 3, 2, 1}\nsort(v.begin(), v, end(), greater&#x3C;int>()); \n// 비교함수를 만들어 정렬하기\nbool cmp(const int &#x26;u, const int &#x26;v) { // u가 앞에 v 앞에 있는 것이\n    return u > v;                      // u가 v보다 클 때만 허용이 됨을 의미\n}\nsort(v.begin(), v.end(), cmp);\n// 비교함수를 람다함수로 정의하여 정렬하기\nsort(v.begin(), v.end(), [](int u, int v) {\n    return u > v;\n});\n</code></pre>\n</li>\n<li>백준 문제: 단어정렬, 좌료정렬하기 ... </li>\n<li>pair 또는 tuple로 만들어서 비교하는 것도 좋은 방법 (그러면 한번에 비교하여 정렬 가능)! (위 두 문제 참고)</li>\n</ul>\n<h4>Stable_sort</h4>\n<ul>\n<li><code>stable_sort(begin, end)</code>: sort와 동일하나, 같은 것이 있는 경우에 정렬하기 전의 순서를 유지한다 (sort는 유지를 보장할 수 없음)</li>\n<li><code>stable_sort(begin, end, cmp)</code>: 마찬가지.</li>\n<li><em>버블 정렬(bubble sort)</em> 와 <em>머지 소트(merge sort)</em> 가 대표적인 stable sort에 해당한다.</li>\n</ul>\n<h4>Binary_search</h4>\n<ul>\n<li><code>binary_search(begin, end, value)</code>: [begin, end) 범위 내에서 value의 값을 <em>이분탐색</em> 하여, 찾으면 true, 못 찾으면 false를 반환한다.</li>\n<li>\n<p>주의:</p>\n<ul>\n<li><em>정렬된 상태</em> 로 사용했을 때 효과가 있다.</li>\n<li>\n<p>찾는 value의 인덱스 값은 알 수 없으며, <em>단순히 value가 존재하는지 안 하는지의 여부만 알 수 있다</em>. (위치는 lower<em>bound나 upper</em>bound를 사용하면 된다)</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {1, 2, 5};\nfor (int i = 1; i &#x3C;= 5; i++) {\n// 있으면 true, 없으면 false 반환\ncout &#x3C;&#x3C; i &#x3C;&#x3C; \" : \" &#x3C;&#x3C; binary_search(v.begin, v.end(), i); \n} \n</code></pre>\n</li>\n</ul>\n</li>\n<li><code>binary_search(begin, end, value, cmp)</code>: [begin, end) 범위 내에서 value의 값을 cmp의 기준으로, 찾으면 true, 못 찾으면 false를 반환한다.</li>\n</ul>\n<h4>Lower<em>bound &#x26; Upper</em>bound</h4>\n<ul>\n<li><code>lower_bound(begin, end, value)</code>: [begin, end) 범위 내에서 <strong>value 보다 작지 않은 첫번째 이터레이터를 반환</strong> 한다.</li>\n<li><code>upper_bound(begin, end, value)</code>: [begin, end) 범위 내에서 <strong>value 보다 큰 첫번째 이터레이터를 반환</strong> 한다.</li>\n<li>범위 내에 찾는 값(모두 값보다 작을 경우)이 <strong>존재하지 않는다면, end 값을 반환</strong> 한다</li>\n<li><strong>정렬 된 상태에서 사용</strong>해야 효과가 있다!</li>\n<li>\n<p><strong>binary_search를 통해 구현</strong> 이 되어 있어, 어떤 값의 _)위치(by 이터레이터)__ 를 알고 싶을 때 사용한다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {1, 2, 3, 3, 4};\n// value의 값이 하나만 존재하면, lower_bound는 그 자리를, upper_bound는 그 다음 인덱스를 가르킴 \nauto l = lower_bound(v.begin(), v.end(), 1); // 1자리 (0 인덱스)\nauto r = upper_bound(v.begin(), v.end(), 1); // 2 자리 (1 인덱스)\n// value의 값이 중복되면, lower_bound는 처음 자리를, upper_bound는 그 다음 큰 숫자의 인덱스를 가르킴 \nauto l = lower_bound(v.begin(), v.end(), 3); // 3자리 (2 인덱스)\nauto r = upper_bound(v.begin(), v.end(), 3); // 4 자리 (4 인덱스)\n</code></pre>\n</li>\n<li>\n<p>정렬된 상태에서 <em>value의 개수</em> 를 찾는데 사용할 수도 있다 (<code>equal_range</code>를 사용하면 더 쉽게 한 번에 구할 수 있다!)</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {1, 2, 3, 3, 4};\nauto l = lower_bound(v.begin(), v.end(), 3); // 3자리 (2 인덱스)\nauto r = upper_bound(v.begin(), v.end(), 3); // 4 자리 (4 인덱스)\nint n = l - r; // 4 - 2 = 2개\n// 한 번에 lower_bound와 upper_bound를 구해 pair 형태로 반환\nequal_range(v.begin(), v.end(), 3);\n</code></pre>\n</li>\n</ul>\n<h4>Min &#x26; Max</h4>\n<ul>\n<li><code>min(a, b)</code> &#x26; <code>max(a, b)</code>: 각 각 두 수 중 최소값, 최대값을 반환한다. (두 수만 비교)</li>\n<li>\n<p><code>min(initializer_list)</code> &#x26; <code>max(initializer_list)</code>:</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nint a = 10, b = 20, c = 30;\n// 최소값과 최대값 구하기 (두 수 비교)\ncout &#x3C;&#x3C; min(a, b) &#x3C;&#x3C; max(a, b);\n// list 형태로 입력값을 주어 최소값과 최대값 구하기\ncout &#x3C;&#x3C; min({a, b, c}) &#x3C;&#x3C; max({a, b, c});\n</code></pre>\n</li>\n<li>\n<p>compare 함수를 정의하여 사용할 수도 있다.</p>\n<pre><code class=\"language-cpp\">string u = \"long string\";\nstring v = \"short\";\n// 문자열의 최소값은 첫번째 값의 ascii 값 (사전순)으로 찾음\ncout &#x3C;&#x3C; min(u, v); // \n// 비교 함수를 정의하여 사용하면, 길이 비교하여 최소값 찾을 수 있음\ncout &#x3C;&#x3C; min(u, v [](string u, string v) {\n    return u.size() &#x3C; v.size();\n})\n</code></pre>\n</li>\n<li><code>minmax(a, b)</code>, <code>minmax(a, b, cmp)</code>, <code>minmax(initializer_list)</code>, <code>minmax(initializer_list, cmp)</code> 사용을 통해 동시에 min과 max값을 구할 수 있다.</li>\n</ul>\n<h4>Min<em>element &#x26; Max</em>element</h4>\n<ul>\n<li><code>min_element(begin, end)</code>: [begin, end)에서 최소값의 <em>이터레이터</em> 를 구한다.</li>\n<li><code>max_element(begin, end)</code>: [begin, end)에서 최대값의 <em>이터레이터</em> 를 구한다.</li>\n<li>\n<p><code>min_element(begin, end, cmp)</code> &#x26; <code>max_element(begin, end, cmp)</code> : [begin, end)에서 비교함수를 기준으로 최소값과 최대값의 <em>이터레이터</em> 를 구한다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {4, 2, 1, 5, 3};\n// 이터레이터를 구하면 값과 인덱스 모두 사용할 수 있음\nauto it = min_element(v.begin(), v.end());\ncout &#x3C;&#x3C; *it &#x3C;&#x3C; \"의 위치는 \" &#x3C;&#x3C; it - v.begin(); \nauto it = max_element(v.begin(), v.end());\ncout &#x3C;&#x3C; *it &#x3C;&#x3C; \"의 위치는 \" &#x3C;&#x3C; it - v.begin(); \n</code></pre>\n</li>\n<li>마찬가지로 <code>minmax_element(begin, end)</code>와 <code>minmax_element(begin, end, cmp)</code>를 사용하여 최소와 최대값의 이터레이터를 구할 수 있다.</li>\n</ul>\n<h4>Next_permutation</h4>\n<ul>\n<li><code>next_permutation(begin, end)</code>: [begin, end)를 순열이라고 생각했을 때, 사전 순으로 다음에 오는 순열을 만든다.</li>\n<li><code>prev_permutation(begin, end)</code>: 사전 순으로 그 전에 오는 순열을 만든다.</li>\n<li>\n<p><code>next_permutation(begin, end, cmp)</code>와 <code>prev_permutation(begin, end, cmp)</code>를 통해 비교 함수를 정의하여 사용할 수도 있다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;vector>\n#include &#x3C;algorithm>\nvector&#x3C;int> v = {1, 2, 3};\n// false를 리턴하는 마지막 순열까지 출력\nwhile (next_permutation(v.begin(), v.end())) {\n    for (int x: v) cout &#x3C;&#x3C; x;\n}\n// 차례대로 출력: 132, 213, 231, 312, 321\n``\n</code></pre>\n</li>\n</ul>","frontmatter":{"path":"/baekjoon/STL/STL_algorithm","title":"[백준] STL 05. 알고리즘","date":"2019-01-28","tags":["백준","Cpp","STL"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}
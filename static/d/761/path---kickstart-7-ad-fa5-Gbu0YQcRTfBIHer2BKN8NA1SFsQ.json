{"data":{"markdownRemark":{"html":"<blockquote>\n<p>Kick Start 2019 대회 후기입니다</p>\n</blockquote>\n<h3>Round A</h3>\n<h3>Training</h3>\n<ul>\n<li>\n<p><strong>다이나믹 프로그래밍</strong> 으로 문제풀기</p>\n<ul>\n<li>\n<p>s[ N]개의 값 중 P개를 골라 (p[ P]), 그 중 최대값과 각각 다른 값의 차이의 합의 최소값 구하기</p>\n<ul>\n<li>선택한 (p[ 최대] - p[다른 거 1]) + (p[ 최대] - p[다른 거 2]) + ... => 총 P-1 개의 차이값들의 합</li>\n<li>그 차이의 합이 최소인 값 구하기</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>내가 푼 방법:</p>\n<ol>\n<li>일단 차이의 합이 최소가 되야하므로, 선택한 P개의 값들은 <em>정렬했을 때 연속된 값들</em> 이어야 한다. so 일단 오름차순으로 s[ N] 정렬</li>\n<li>\n<p>다이나믹 프로그래밍으로 풀기: s[ N]개 중 처음부터 P개씩 묶는다는 생각으로, s [ P]를 기준으로 그전 P-1 개의 값들과의 <em>차이의 합을 계산</em></p>\n<ul>\n<li>비효율적인 방법: (s[ P] - s[ P-1]) + (s[ P] - s[ P-2]) + ... + (s[ P] - s[ 1]) => 총 P-1개의 차이의 합</li>\n<li>차선: d[n] = d[n-1] + s[i]</li>\n</ul>\n</li>\n<li>d[n] 값 중 <em>최소값 구하기</em></li>\n</ol>\n</li>\n<li>\n<p>1등이 푼 방법 (비교):</p>\n</li>\n<li>\n<p><strong>결론</strong>:</p>\n<ul>\n<li>다이나믹 프로그래밍을 사용하는 큰 그림은 일단 맞추었다! (각 test case 마다 O(N)의 시간복잡도를 가능한 줄였다!)</li>\n<li>but, 1등이 푼 방법이 더 효율적인 듯! (한 번 이해를 하니, 더 간단하게 )</li>\n</ul>\n</li>\n</ul>\n<h4>Parcels</h4>\n<h4>Contention</h4>\n<h3>What I learned</h3>\n<h4>채점 결과 WA (Wrong Answer) 의미</h4>\n<ol>\n<li><strong>Sample Failed</strong>: Output이 잘못됨 (결과값 또는 출력형식의 오류)</li>\n<li><strong>test Case Skipped</strong>: time limit 초과로 모든 test case를 프로그램이 접근하지 못한 경우</li>\n</ol>\n<h4>느낌</h4>\n<ul>\n<li>공부를 더 열심히 해야겠다, 아직 많이 부족함을 느꼈다</li>\n<li>3시간 안에 1문제 성공적으로 풀고 2번째 문제 코드 다 쓰고서 고쳐나가던 중...</li>\n<li>일단 시스템 오류만 아니었으면 (오류로 15분 연장되었으나, 끝에 15분에 제출이 되지 않는 오류) 첫 번째 문제는 통과되었을 것...ㅠㅜ</li>\n<li>시스템 오류로 바로 3번째 문제부터 풂...ㅠㅜ(원래 1,2,3 순서대로 푸는 게 좋은데ㅠㅜ) 그래서 시간이 더 오래걸렸던 듯ㅜㅠ</li>\n<li>잘하는 분들은 보니까 각자 기본적인 설정 같은 거를 만들어두고서 복사해와 사용하는 것 같다, 나도 만들까?</li>\n</ul>","frontmatter":{"path":"/kickstart","title":"Google Kick Start 2019 후기","date":"2019-03-24","tags":["C++","치트키"]}}},"pageContext":{}}
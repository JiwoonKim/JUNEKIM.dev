{"data":{"markdownRemark":{"html":"<h3>입출력</h3>\n<ul>\n<li><code class=\"language-text\">cin</code>와 <code class=\"language-text\">cout</code> 사용.</li>\n<li><code class=\"language-text\">getline(cin, s)</code>: 한 줄 읽기</li>\n</ul>\n<h4>실수 출력</h4>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ndouble f = 3.14159;\ncout &lt;&lt; setprecision(5) &lt;&lt; f ; // 총 5글자 반올림하여 출력: 3.1416\ncout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; f; // 소수점 5자리까지 출력: 3.1415</code></pre></div>\n<h4>출력 속도</h4>\n<ul>\n<li>endl는 flush까지 포함하기 때문에 '\\n'을 사용하는 것이 빠르다.</li>\n<li>printf가 cout보다 빠르다.</li>\n<li>cin/cout 사용 전에 <code class=\"language-text\">ios_base::sync_with_stdio(false);</code>를 사용하면  printf의 속도로 사용가능 (단, cin/cout을 scanf/printf와 같이 사용할 수 없음)</li>\n</ul>\n<h3>auto 자료형</h3>\n<ul>\n<li>컴파일러가 자료형 타입을 추론해서 타입을 결정한다.</li>\n<li>\n<p>변수의 타입을 명확하게 알 수 있게 value를 assign해야 함.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">auto a;     // 자료형을 추론할 수 없기에 컴파일 에러가 뜸\nauto b = 0; // 자료형이 추론 가능</code></pre></div>\n</li>\n<li>\n<p>iterator로 사용할 때 매우 편리하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include\nmap&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int,string&gt;&gt;&gt; d;\nfor (auto it = d.begin(); ...) //길게 자료형을 선언해야 하는 대신 auto 편리하게 사용</code></pre></div>\n</li>\n</ul>\n<h3>range-based FOR</h3>\n<ul>\n<li>\n<p>foreach에 해당하는 문법.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include\nvector&lt;int&gt; a = {1, 2, 3, 4, 5};\nfor (auto x : a) {...}</code></pre></div>\n</li>\n</ul>\n<h3>람다 함수 (Lamda Function)</h3>\n<ul>\n<li>\n<p>이름이 없는 익명 함수: [캡쳐] (함수인자) {함수내용}으로 정의한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">cout &lt;&lt; [](int x, int y) {\nreturn x + y; \n}(1, 2);</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">auto sum = [](int x, int y) {\nreturn x + y;\n};\ncout &lt;&lt; sum(1, 2);</code></pre></div>\n</li>\n</ul>\n<h4>캡쳐</h4>\n<ul>\n<li>람다 함수의 scope를 어떻게 결정할 것인지를 정하는 부분이다.</li>\n<li>\n<p>[&#x26;]를 통해 람다 함수 밖의 모든 변수를 참조할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">int x;\nauto is_less = [&amp;] (int number) {\nreturn number &lt; x;\n};</code></pre></div>\n</li>\n</ul>\n<h4>리턴 타입</h4>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">function&lt;void()&gt; print = [] {};\nfunction&lt;void(int)&gt; print2 = [](int x) {};\nfunction&lt;int(int,int)&gt; sum = [](int x, int y) {\n    return x + y;\n};</code></pre></div>","frontmatter":{"path":"/algorithm/baekjoon_STL/cpp_basic","title":"[백준] 프로그래밍 대회에서 사용하는 C++ 언어","date":"2018-01-24","tags":["백준","C++","강의노트"]}}},"pageContext":{}}
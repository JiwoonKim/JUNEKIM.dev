{"componentChunkName":"component---src-components-templates-blog-post-js","path":"/web50/9","webpackCompilationHash":"18260c0ffdc80beff4d5","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>Harvard's Web Programming with Python and Javascript lecture 9 정리</p>\n</blockquote>\n<h3>CI / CD</h3>\n<ul>\n<li>\n<p><strong>Continuous Integration</strong>: </p>\n<ul>\n<li>consistently and frequently integrating code together for a team (merging to main branch)</li>\n<li><strong>automating unit testing</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>Continuous Delivery</strong>:</p>\n<ul>\n<li>making <strong>incremental deliveries</strong> to application</li>\n<li><strong>automating application deployment</strong></li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">continuous</code> is the main key!</p>\n<ul>\n<li>have integration and delivery continuously and frequently to avoid the overload and complications of doing each all in one cue</li>\n</ul>\n</li>\n<li>\n<p><strong>virtualization</strong>: create virtual environments to ensure reproducability of apps</p>\n<ul>\n<li>virtual machines(vmware), containers (docker)</li>\n</ul>\n</li>\n</ul>\n<h3>CI (Continuous Integration)</h3>\n<p>a development strategy that revolves around continually and frequently adding code to a codebase (to avoid the complications in integration all in once)</p>\n<ul>\n<li>\n<p><strong>testing</strong>: </p>\n<ul>\n<li>automated tests vs. manual tests</li>\n<li>functional tests vs. non-functional tests </li>\n</ul>\n</li>\n<li>\n<p><strong>CI Tools</strong>: automated testing tool</p>\n<ul>\n<li>CircleCI, Codeship, Jenkins, Travis CI</li>\n</ul>\n</li>\n</ul>\n<h3>Travis CI</h3>\n<ul>\n<li>\n<p><strong>how Travis CI works</strong>:</p>\n<ol>\n<li>push code to GitHub</li>\n<li>GitHub notifies changes to Travis</li>\n<li>Travis pulls code from repo and runs tests</li>\n<li>GitHub notified of test results</li>\n</ol>\n</li>\n<li>\n<p><strong>setup Travis CI</strong>:</p>\n<ol>\n<li>sync GitHub account w/ Travis (<a href=\"https://travis-ci.org\">https://travis-ci.org</a>)</li>\n<li>select repository to be tracked by Travis</li>\n<li>include <code class=\"language-text\">.travis.yml</code> file in repository</li>\n<li>then, after pushes to repo, Travis automatically runs tests and notifies user on Github (in commits)</li>\n</ol>\n</li>\n</ul>\n<h4>Travis YAML</h4>\n<ul>\n<li>\n<p>YAML: common file format used for creating <strong>configuration files</strong></p>\n<ul>\n<li>lists tests, installations, etc.</li>\n<li><strong>set of keys and values</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>Travis YAML file</strong> (<code class=\"language-text\">.travis.yml</code>)</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">language: python\npython: 3.6\ninstall: pip install -r requirements.txt\nscript: python manage.py test</code></pre></div>\n</li>\n</ul>\n<h3>Virtualization</h3>\n<p>isolating an app and its dependencies into a self-contained unit so that they can run anywhere w/o compatibility issues; abstracting the complexities of installing necessary dependencies for an app</p>\n<ul>\n<li>\n<p><strong>compatibility issues</strong>: development environment &#x3C;-> production environment</p>\n<ul>\n<li>how to ensure the production environment will be identical to to development environment?</li>\n</ul>\n</li>\n<li>\n<p><strong>solutions</strong>:</p>\n<ul>\n<li>사진</li>\n<li><strong>virtual machine</strong>: set a virtual operating system w/ configurations and dependencies</li>\n<li><strong>containerization</strong>: creating isolated containers that have just the things we want to have installed on them and use images instead of full-blown virtual machines; very useful in that do not have to install separate parts of app (ex. web server &#x26; database)</li>\n</ul>\n</li>\n</ul>\n<h4>Docker</h4>\n<p>type of container </p>\n<ul>\n<li>\n<p><code class=\"language-text\">DockerFile</code>: <strong>define docker image</strong> (= <strong>instructions for how container should be made</strong>, where app will live in)</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"># inherit python:3 image\nFROM python:3\n# set working directory for app\nWORKDIR /usr/src/app\n# install all the dependencies\nADD requirements.txt /usr/src/app\nRUN pip install -r requirements.txt\n# add all the contents of current directory to app directory\nADD . /usr/src/app</code></pre></div>\n</li>\n<li>\n<p><strong>docker commands</strong>:</p>\n<ul>\n<li><code class=\"language-text\">docker ps</code>: list current docker containers</li>\n<li><code class=\"language-text\">docker build {dir_to_build_image}</code>: build an  image from docker file (by following the instructions)</li>\n<li><code class=\"language-text\">docker run {image_id}</code>: create container based on image and run it</li>\n<li><code class=\"language-text\">docker exec -it {container_id} bash -l</code>: run bash interactively in docker's container</li>\n</ul>\n</li>\n<li>\n<p>cf) <code class=\"language-text\">settings.py</code>: set database for project</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token comment\"># example for Django app (airline project)</span>\nDATABASES <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'default'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\"># setting db to postgres for scalability reasons</span>\n        <span class=\"token string\">'ENGINE'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'django.db.backends.postgresql'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'NAME'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'postgres'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'USER'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'postgres'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'HOST'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'db'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'PORT'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5432</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">docker-compose.yml</code>: <strong>define all of the different services that make up the app</strong>; compose multiple containers</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">version: &#39;3&#39;\nservices:\n# define database service\ndb:\n    # use postgres image to construct db\n    image: postgres\n# define service for migrating changes\nmigration:\n    # build based on the docker file in current directory (-&gt; will tell how to install all dependencies)\n    build: .\n    command: python3 manage.py migrate\n    # link btw different files (current directory and app directory)\n    volumes:\n        - .:/usr/src/app\n    # define dependency (make sure db is up first before using migration service)\n    depends_on:\n        - db\n# define web service\nweb:\n    # build based on docker file in current directory\n    build: .\n    command: python3 manage.py runserver 0.0.0.0:8000\n    volumes:\n        - .:usr/src/app\n    # map port 8000 in container to port 8000 on current environment (computer)\n    ports:\n        - &quot;8000:8000&quot;\n    depends_on:\n        - db\n        - migration</code></pre></div>\n</li>\n<li>\n<p><strong>docker-compose commands</strong>:</p>\n<ul>\n<li><code class=\"language-text\">docker-compose build</code>: build images based on yml file</li>\n<li><code class=\"language-text\">docker-compose up</code>: build images and start containers</li>\n</ul>\n</li>\n</ul>\n<h3>CD (Continuous Delivery)</h3>\n<p>a development strategy that revolves around continually and frequently delivering code to production</p>\n<ul>\n<li>\n<p><strong>CD Tools</strong>: </p>\n<ul>\n<li><strong>deployment</strong>: Heroku, Amazon AWS</li>\n</ul>\n</li>\n</ul>\n<h3>Deployment</h3>\n<h4>Heroku</h4>\n<ul>\n<li>\n<p><strong>how Heroku works</strong>:</p>\n<ol>\n<li></li>\n</ol>\n</li>\n<li>\n<p><strong>deploy app to Heroku</strong>:</p>\n<ol>\n<li>create a new app</li>\n<li>generate Heroku API key -> authorize Travis CI</li>\n</ol>\n</li>\n</ul>\n<h3>Development Workflow</h3>\n<p>a typical day for developers (using ex of GitHub Classroom)</p>\n<h4>Feature-branch Development</h4>\n<p>paradigm to develop new branch for each feature and merge back to master branch (= production branch); a type of strategy for continuous deployment</p>\n<ol>\n<li><strong>fork repo</strong></li>\n<li><code class=\"language-text\">git clone {repo_url}</code>: clone repo to local computer</li>\n<li>\n<p><code class=\"language-text\">git checkout -b {branch_name}</code>: create a feature branch</p>\n<ul>\n<li>make changes for feature </li>\n<li>check the change w/ unit tests</li>\n</ul>\n</li>\n<li><code class=\"language-text\">git push {forked_repo} {branch_name}</code>: push branch to forked repo</li>\n<li>\n<p><strong>compare and pull request</strong>: start conversation about the changes made</p>\n<ul>\n<li>check <code class=\"language-text\">from</code> and <code class=\"language-text\">to</code> repos</li>\n<li><strong>automatically starts a build</strong> (Travis runs unit tests)</li>\n<li><strong>co-workers reviews changes, provide feedback, and discuss changes</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>deployment</strong> (once the pull request is reviewed and accepted)</p>\n<ul>\n<li>\n<p><strong>Feature Flipper</strong>: add code (<strong>feature toggle</strong>) so that a certain feature will appear only in the specified condition (used to deploy new features w/o impacting all users: can beta test while the original one is used for all users); ultimately, the feature toggle will be removed as the code is deployed to an increasing number of users and fully deployed</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token comment\">&lt;!-- if user exists and feature enabled for that user --></span>\n{% if current_user &amp;&amp; current_user.feature_enabled %}\n<span class=\"token comment\">&lt;!-- toggle feature on --></span>\n... feature code\n{% endif %}</code></pre></div>\n<ul>\n<li>use feature flipping to <strong>continuously deploy features and code</strong></li>\n</ul>\n</li>\n<li><strong>pull request to actual repo and push code</strong> not the forked repo (Travis creates builds)</li>\n<li>\n<p><strong>deploy for production</strong></p>\n<ul>\n<li>deployment may occur in chatroom (slack) instead of in command line</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>cf) <strong>released-based development</strong>: builds up the version 1.0 branch while also working on a 1.1 branch</p>","frontmatter":{"path":"/web50/9","title":"Web50 lecture 9 - CI/CD","date":"2019-06-18","tags":["CS50","Web50","CI/CD"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}